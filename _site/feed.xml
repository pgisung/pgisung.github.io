<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-02T05:31:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JohnnyPark</title><subtitle>The growth diary of Software developer JohnnyPark</subtitle><entry><title type="html">12. 프로젝트를 관리해 보자</title><link href="http://localhost:4000/github/2023/10/23/Managing-project/" rel="alternate" type="text/html" title="12. 프로젝트를 관리해 보자" /><published>2023-10-23T09:03:29+09:00</published><updated>2023-10-23T09:03:29+09:00</updated><id>http://localhost:4000/github/2023/10/23/Managing-project</id><content type="html" xml:base="http://localhost:4000/github/2023/10/23/Managing-project/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#태그로-버전-생성하기" title="Navigate to Creating version by tag">태그로 버전 생성하기</a>
      <ul>
        <li><a href="#버전이란" title="Navigate to What is version?">버전이란?</a></li>
        <li><a href="#태그란" title="Navigate to What is tag?">태그란?</a></li>
      </ul>
    </li>
    <li><a href="#프로젝트-관리하기" title="Navigate to Managing project">프로젝트 관리하기</a>
      <ul>
        <li><a href="#이슈-발급하기" title="Navigate to Creating issue">이슈 발급하기</a></li>
        <li><a href="#레이블로-이슈-분류하기" title="Navigate to Labeling issues">레이블로 이슈 분류하기</a></li>
        <li><a href="#마일스톤으로-진행도-관리하기" title="Navigate to Managing progress by milestone">마일스톤으로 진행도 관리하기</a></li>
        <li><a href="#프로젝트-작업-흐름-관리하기" title="Navigate to Managing project work flow">프로젝트 작업 흐름 관리하기</a></li>
      </ul>
    </li>
    <li><a href="#pull-request로-코드-리뷰-및-병합-요청하기" title="Navigate to Pull request and code review">Pull request로 코드 리뷰 및 병합 요청하기</a>
      <ul>
        <li><a href="#pull-request-생성하기" title="Navigate to Creating pull request">Pull request 생성하기</a></li>
        <li><a href="#코드-리뷰하기" title="Navigate to Reviewing code">코드 리뷰하기</a></li>
        <li><a href="#리뷰가-완료된-코드-병합하기" title="Navigate to Merging code that completed reviewing">리뷰가 완료된 코드 병합하기</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="태그로-버전-생성하기"><span style="color: brown"><strong>태그로 버전 생성하기</strong></span></h4>
<h5 id="버전이란"><strong>버전이란?</strong></h5>
<p>버전은 <span style="color: #8D4801"><strong>소프트웨어의 특정 시점을 식별</strong></span>하기 위해 숫자, 알파벳, 또는 기호의 조합으로 명명하는 식별자이다. 그중에 대표적으로 <span style="color: #8D4801"><strong>세 자리 숫자 형태로 표기하는 SemVer 방식</strong></span>이 있다.</p>
<center><img src="/images/posts/2023-10-23-Managing-project/reference-of-semantic-versioning.webp" title="Reference of semantic versioning" alt="Reference of semantic versioning" /></center>

<ul>
  <li><span style="color: red"><strong>메이저 버전 (Major version)</strong></span>
    <ul>
      <li>주요 기능이나 구조적 변경이 있을 때 증가한다.</li>
      <li>첫 자리가 0으로 시작하면 아직 초기 개발 중인 제품이라는 의미이다. 정식 버전은 1부터 시작한다.</li>
      <li>예를 들어, 1.0, 2.0, 3.0 등…</li>
    </ul>
  </li>
  <li><span style="color: green"><strong>마이너 버전 (Minor version)</strong></span>
    <ul>
      <li>기능의 추가나 수정이 있을 때 증가한다. 주로 작은 변경 사항이나 새로운 기능이 추가될 때 증가한다.</li>
      <li>예를 들어, 1.1, 1.2, 1.3 등…</li>
    </ul>
  </li>
  <li><span style="color: dodgerblue"><strong>패치 버전 (Patch version)</strong></span>
    <ul>
      <li>주로 버그 수정이나 보안 패치 등의 작은 변경 사항이 있을 때 증가한다.</li>
      <li>예를 들어, 1.1.1, 1.1.2, 1.1.3 등…</li>
    </ul>
  </li>
  <li><strong>추가적인 형태</strong>
    <ul>
      <li>버전 용어
        <ul>
          <li><span style="color: #8D4801">Alpha</span> : 소프트웨어가 개발 초기 단계에 있음을 나타낸다. 주요 기능이 아직 완전히 구현되지 않았으며, 많은 버그와 결함이 있을 수 있다. 일반적으로 내부 개발 및 테스트 목적으로 사용된다.</li>
          <li><span style="color: #8D4801">M (Milestone)</span> : 테스트 버전을 의미한다. 개발 과정 중 중요한 이정표 또는 중간 단계를 나타낸다. 일반적으로 특정 기능 또는 목표를 달성할 때마다 테스트하여 피드백을 받는 버전을 의미한다.</li>
          <li><span style="color: #8D4801">Beta</span> : 개발 중인 소프트웨어가 비교적 안정적인 상태에 도달했지만, 아직 완전한 릴리스에는 못 미친 상태를 나타낸다. 이 단계에서는 주요 기능이 대부분 구현되었으며, 외부 사용자에게 테스트 및 피드백을 받기 위해 제공될 수 있다.</li>
          <li><span style="color: #8D4801">RC (Release Candidate)</span> : 릴리스 후보 버전을 나타낸다. 이 단계에서는 소프트웨어의 주요 기능이 거의 완료되었으며, 릴리스에 대한 최종 검토 및 테스트가 이루어진다.</li>
          <li><span style="color: #8D4801">GA (General Availability)</span> : 테스트가 완료된 정식 릴리스 버전을 의미한다. 지금까지의 과정 중 가장 안정된 버전으로 일반적으로 모든 사용자에게 공개되는 최종 릴리스 버전이다.</li>
        </ul>
      </li>
      <li>버전 용어를 접미사에 붙여서 개발 단계를 나타내기도 한다.</li>
      <li>예를 들어, 1.0-alpha, 1.0-m, 1.0-beta, 1.0-rc, 1.0-ga 등…</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="태그란"><strong>태그란?</strong></h5>
<p>Tag 단어는 꼬리표라는 뜻이 있다. 단어의 뜻과 같이 <span style="color: #8D4801"><strong>Git의 tag란 특정 커밋의 해시값을 참조하는 꼬리표</strong></span>를 의미한다. Git의 tag에는 크게 <a href="#annotated-tag" title="Navigate to Annotated tag"><strong>Annotated 태그</strong></a>와 <a href="#lightweight-tag" title="Navigate to Lightweight tag"><strong>Lightweight 태그</strong></a> 두 가지 종류의 태그가 존재한다. 또한 <span style="color: indianred"><strong>태그는 중복해서 생성할 수 없다. Git에 등록된 태그 이름은 유일해야 하며, 중복된 이름으로 태그 생성을 시도할 시 오류 메시지를 출력</strong></span>한다.</p>

<center><img src="/images/posts/2023-10-23-Managing-project/tag-in-naver-dictionary.jpg" title="Definition of tag in Naver dictionary" alt="Definition of tag in Naver dictionary" /></center>

<center>
  <a href="https://dict.naver.com/dict.search?dicQuery=tag&amp;query=tag&amp;target=dic&amp;ie=utf8&amp;query_utf&amp;isOnlyViewEE" title="Navigate to Naver dictionary">
    <small><i class="fa fa-copyright" aria-hidden="true"></i>네이버 사전</small>
  </a>
</center>

<ul>
  <li><strong>태그 목록보기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag
</code></pre></div>    </div>
    <ul>
      <li>로컬 저장소에 존재하는 <span style="color: #8D4801"><strong>모든 태그 이름의 목록을 표시</strong></span>한다.
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag.jpg" title="Git command to show list of all tags in local repository" alt="Git command to show list of all tags in local repository" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>패턴이 일치하는 태그 목록보기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">-l</span> &lt;<span class="s2">"패턴"</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">--list</span> &lt;<span class="s2">"패턴"</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <ul>
      <li>로컬 저장소에 존재하는 <span style="color: #8D4801"><strong>지정된 패턴과 일치하는 태그 이름의 목록을 표시</strong></span>한다.
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag-l-pattern.jpg" title="Git command to show list of tags matching with pattern in local repository" alt="Git command to show list of tags matching with pattern in local repository" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Log에서 태그 확인하기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--decorate</span>
</code></pre></div>    </div>
    <p><img src="/images/posts/2023-10-23-Managing-project/git-command-log-decorate.jpg" title="Git command to show log with tag information" alt="Git command to show log with tag information" /></p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>태그의 상세 정보 확인</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git show &lt;태그 이름&gt;
</code></pre></div>    </div>
    <ul>
      <li>이 명령어로 상세 정보를 확인할 때 아래의 표시된 태그 관련 상세 정보는 <span style="color: #8D4801"><strong>Lightweight 태그에는 존재하지 않는다.</strong></span>
<img src="/images/posts/2023-10-23-Managing-project/git-command-show-tag-name.jpg" title="Git command to show log of the tag" alt="Git command to show log of the tag" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><span id="annotated-tag"></span><strong>Annotated 태그</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">-a</span> &lt;버전&gt;
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">--annotate</span> &lt;버전&gt;
</code></pre></div>    </div>
    <ul>
      <li>
        <p>태그 이름뿐만 아니라 <span style="color: #8D4801"><strong>간단한 태그 정보를 포함하는 태그</strong></span>를 생성하는 명령어이다. 명령어 실행 시 정보를 입력할 수 있도록 에디터가 실행된다. 특정 커밋 해시값을 입력하지 않을 경우 기본적으로 HEAD 커밋을 기준으로 태그를 생성한다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-23-Managing-project/before-git-command-tag-a.jpg" title="Tag list before git command tag -a" alt="Tag list before git command tag -a" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag-a.jpg" title="Git command to create annotated tag" alt="Git command to create annotated tag" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-23-Managing-project/after-git-command-tag-a.jpg" title="Tag list after git command tag -a" alt="Tag list after git command tag -a" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>간이 태그 메시지 작성 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">-a</span> &lt;버전&gt; <span class="nt">-m</span> &lt;<span class="s2">"태그 메시지"</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">-a</span> &lt;버전&gt; <span class="nt">--message</span> &lt;<span class="s2">"태그 메시지"</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <ul>
      <li>
        <p>Annotated 태그를 생성할 때는 반드시 태그 메시지를 작성해야 한다. 이 옵션을 사용하면 <span style="color: #8D4801"><strong>에디터를 사용하지 않고 간이 태그 메시지를 작성하여 태그를 추가</strong></span>할 수 있다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-23-Managing-project/before-git-command-tag-a-m.jpg" title="Tag list before git command tag -a version -m message" alt="Tag list before git command tag -a version -m message" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag-a-m.jpg" title="Git command to create annotated tag with simple message" alt="Git command to create annotated tag with simple message" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-23-Managing-project/after-git-command-tag-a-m.jpg" title="Tag list after git command tag -a version -m message" alt="Tag list after git command tag -a version -m message" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><span id="lightweight-tag"></span><strong>Lightweight 태그</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag &lt;버전&gt;
</code></pre></div>    </div>
    <ul>
      <li>
        <p>가장 기본적인 태그로써 Annotated 태그와 달리 <span style="color: #8D4801"><strong>태그 이름만 존재</strong></span>한다. .git/ref/tags/ 경로 안에 해당 태그 이름의 파일을 생성하고 파일 내용에 참조할 커밋 해시값을 작성할 시 명령어와 동일하게 태그를 생성할 수 있다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-23-Managing-project/before-git-command-tag-version.jpg" title="Tag list before git command tag version" alt="Tag list before git command tag version" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag-version.jpg" title="Git command to create lightweight tag" alt="Git command to create lightweight tag" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-23-Managing-project/after-git-command-tag-version.jpg" title="Tag list after git command tag version" alt="Tag list after git command tag version" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>태그 삭제하기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">-d</span> &lt;태그 이름&gt;
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git tag <span class="nt">--delete</span> &lt;태그 이름&gt;
</code></pre></div>    </div>
    <ul>
      <li>
        <p>태그 목록에서 삭제된 태그 이름은 태그를 생성할 때 다시 사용할 수 있다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-23-Managing-project/before-git-command-tag-d.jpg" title="Tag list before git command tag -d" alt="Tag list before git command tag -d" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-23-Managing-project/git-command-tag-d.jpg" title="Git command to delete tag in local repository" alt="Git command to delete tag in local repository" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-23-Managing-project/after-git-command-tag-d.jpg" title="Tag list after git command tag -d" alt="Tag list after git command tag -d" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>태그 이동하기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch <span class="nt">--detach</span> &lt;태그 이름&gt;
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;태그 이름&gt;
</code></pre></div>    </div>
    <ul>
      <li>브랜치간 이동하듯이 <span style="color: #8D4801"><strong>태그가 참조하는 커밋으로의 이동</strong></span> 또한 가능하다.
<img src="/images/posts/2023-10-23-Managing-project/git-command-switch-detach.jpg" title="Git command to switch to the tag" alt="Git command to switch to the tag" /></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="프로젝트-관리하기"><span style="color: brown"><strong>프로젝트 관리하기</strong></span></h4>
<h5 id="이슈-발급하기"><strong>이슈 발급하기</strong></h5>
<ol>
  <li>
    <p>먼저 해당 저장소의 Settings에서 Issues 기능이 활성화 되어있어야 한다.
<img src="/images/posts/2023-10-23-Managing-project/creating-github-issue-1.jpg" title="Settings tab for the remote repository" alt="Settings tab for the remote repository" /></p>
  </li>
  <li>
    <p>저장소의 Issues 탭으로 이동하여 New issue 버튼을 눌러서 새로운 issue 생성을 진행하자.
<img src="/images/posts/2023-10-23-Managing-project/creating-github-issue-2.jpg" title="Issues tab for the remote repository" alt="Issues tab for the remote repository" /></p>
  </li>
  <li>
    <p>설정된 Issue template이 존재할 경우 해당 페이지가 표시될 수 있고 존재하지 않을 경우 바로 다음 페이지가 표시될 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/creating-github-issue-3.jpg" title="Selection of issue templates" alt="Selection of issue templates" /></p>
  </li>
  <li>
    <ul>
      <li>Title에 issue 제목을 작성한다.</li>
      <li>Description에 해당 issue의 작업 목적 및 수행할 task를 작성한다.</li>
      <li>Assignees에 작업을 수행할 담당자를 작성하고 해당하는 Labels, Projects, Milestone을 설정한다.
<img src="/images/posts/2023-10-23-Managing-project/creating-github-issue-4.jpg" title="Page to write issue" alt="Page to write issue" /></li>
    </ul>
  </li>
  <li>생성이 완료된 issue의 화면이다. <span style="color: #8D4801"><strong>각 issue는 #으로 시작하는 고유번호</strong></span>를 갖고 있으며 commit, pull request 등의 명령어 실행 시 서로를 참조하는 데 사용할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/creating-github-issue-5.jpg" title="Completed issue page" alt="Completed issue page" /></li>
</ol>

<p><br /></p>

<h5 id="레이블로-이슈-분류하기"><strong>레이블로 이슈 분류하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Issues 탭으로 이동하여 Labels 버튼을 눌러서 Labels 관리 화면으로 이동한다.
<img src="/images/posts/2023-10-23-Managing-project/issue-labeling-1.jpg" title="Issues tab for the remote repository" alt="Issues tab for the remote repository" /></p>
  </li>
  <li>
    <p>New label 버튼을 눌러서 새로운 label을 생성할 수도 있고 Edit, Delete 버튼을 눌러서 기존의 label을 편집할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/issue-labeling-2.jpg" title="Labels tab for the remote repository" alt="Labels tab for the remote repository" /></p>
  </li>
  <li>
    <p>Issue 작성 화면에서 해당 <span style="color: #8D4801"><strong>issue에 특정 label을 추가</strong></span>할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/issue-labeling-3.jpg" title="Label list in page to write issue" alt="Label list in page to write issue" /></p>
  </li>
</ol>

<p><br /></p>

<h5 id="마일스톤으로-진행도-관리하기"><strong>마일스톤으로 진행도 관리하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Issues 탭으로 이동하여 Milestones 버튼을 눌러서 Milestones 관리 화면으로 이동한다.
<img src="/images/posts/2023-10-23-Managing-project/setting-milestone-1.jpg" title="Issues tab for the remote repository" alt="Issues tab for the remote repository" /></p>
  </li>
  <li>
    <p>New milestone 버튼을 눌러서 새로운 milestone을 생성할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/setting-milestone-2.jpg" title="Milestones tab for the remote repository" alt="Milestones tab for the remote repository" /></p>
  </li>
  <li>
    <p>Milestone의 제목과 Deadline 그리고, 내용을 작성하고 Create milestone 버튼을 눌러서 생성을 완료한다.
<img src="/images/posts/2023-10-23-Managing-project/setting-milestone-3.jpg" title="Page to write milestone" alt="Page to write milestone" /></p>
  </li>
  <li>
    <p>Issue 작성 화면에서 해당 issue에 특정 milestone을 추가할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/setting-milestone-4.jpg" title="Milestone list in page to write issue" alt="Milestone list in page to write issue" /></p>
  </li>
  <li>
    <p>Milestone에 grouping 된 <span style="color: #8D4801"><strong>issue의 상태에 따라 진행도를 확인</strong></span>할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/setting-milestone-5.jpg" title="Milestone Progress bar in Milestones tab for the remote repository" alt="Milestone Progress bar in Milestones tab for the remote repository" /></p>
  </li>
</ol>

<p><br /></p>

<h5 id="프로젝트-작업-흐름-관리하기"><strong>프로젝트 작업 흐름 관리하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Prpjects 탭으로 이동하여 New project 버튼을 눌러서 Project 생성 화면으로 이동한다.
<img src="/images/posts/2023-10-23-Managing-project/managing-project-work-flow-1.jpg" title="Projects tab for the remote repository" alt="Projects tab for the remote repository" /></p>
  </li>
  <li>
    <p>원하는 Project의 레이아웃을 선택한다. 필자는 Kanban을 선택했다.
<img src="/images/posts/2023-10-23-Managing-project/managing-project-work-flow-2.jpg" title="Selection for project templates" alt="Selection for project templates" /></p>
  </li>
  <li>
    <p>Project 이름을 입력하고 Create project 버튼을 눌러서 Project를 생성한다.
<img src="/images/posts/2023-10-23-Managing-project/managing-project-work-flow-3.jpg" title="Dialog to create project" alt="Dialog to create project" /></p>
  </li>
  <li>
    <p>생성된 Project 화면이다. Add item 버튼을 통하여 원하는 column에 이슈를 추가할 수 있다. 이 화면에서 <span style="color: #8D4801"><strong>이슈를 이용하여 프로젝트의 작업 흐름을 관리</strong></span>할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/managing-project-work-flow-4.jpg" title="Page to manage project" alt="Page to manage project" /></p>
  </li>
</ol>

<hr />

<h4 id="pull-request로-코드-리뷰-및-병합-요청하기"><span style="color: brown"><strong>Pull request로 코드 리뷰 및 병합 요청하기</strong></span></h4>
<h5 id="pull-request-생성하기"><strong>Pull request 생성하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Pull requests 탭으로 이동하여 생성하고자 하는 브랜치의 pull request 버튼을 눌러서 진행한다. <span style="color: #8D4801"><strong>이때 pull request하고자 하는 작업 내용들은 원격저장소에 전송되어 있어야 한다.</strong></span>
<img src="/images/posts/2023-10-23-Managing-project/creating-pull-request-1.jpg" title="Pull requests tab for the remote repository" alt="Pull requests tab for the remote repository" /></p>
  </li>
  <li>
    <p>Pull request 생성에 필요한 정보들을 입력 후 Create pull request 버튼을 눌러 생성을 완료한다. Description에 <span style="color: #8D4801"><strong>[close/fix/resolve]: #issue 번호</strong></span> 형태의 구문 작성 시 해당 issue를 참조하여 코드 병합 시 issue를 자동으로 닫을 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/creating-pull-request-2.jpg" title="Page to write pull request" alt="Page to write pull request" /></p>
  </li>
  <li>
    <p>생성된 pull request를 확인할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/creating-pull-request-3.jpg" title="Pull requests tab for the remote repository" alt="Pull requests tab for the remote repository" /></p>
  </li>
</ol>

<p><br /></p>

<h5 id="코드-리뷰하기"><strong>코드 리뷰하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Pull requests 탭으로 이동하여 리뷰하고자 하는 pull request를 선택한다.
<img src="/images/posts/2023-10-23-Managing-project/reviewing-code-1.jpg" title="Pull requests tab for the remote repository" alt="Pull requests tab for the remote repository" /></p>
  </li>
  <li>
    <p>화면 하단에 해당 pull request에 대한 전체적인 리뷰를 남길 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/reviewing-code-2.jpg" title="Comment box in Pull requests tab" alt="Comment box in Pull requests tab" /></p>
  </li>
  <li>
    <p>File changed 탭으로 이동하여 각 파일의 변경 사항에 대한 리뷰 또한 남길 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/reviewing-code-3.jpg" title="Files changed tab in Pull requests tab" alt="Files changed tab in Pull requests tab" /></p>
  </li>
</ol>

<p><br /></p>

<h5 id="리뷰가-완료된-코드-병합하기"><strong>리뷰가 완료된 코드 병합하기</strong></h5>
<ol>
  <li>
    <p>저장소의 Pull requests 탭으로 이동하여 병합하고자 하는 pull request를 선택한다. 보통은 저장소에 일정 이상의 권한을 가진 사람만이 PR을 병합할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/merging-code-completed-reviewing-1.jpg" title="Pull requests tab for the remote repository" alt="Pull requests tab for the remote repository" /></p>
  </li>
  <li>
    <p>Merge pull request 버튼을 눌러서 병합을 진행한다.
<img src="/images/posts/2023-10-23-Managing-project/merging-code-completed-reviewing-2.jpg" title="Merge part in Pull requests tab" alt="Merge part in Pull requests tab" /></p>
  </li>
  <li>
    <p>병합 정보를 입력 후 Confirm merge 버튼을 눌러서 병합을 완료한다.
<img src="/images/posts/2023-10-23-Managing-project/merging-code-completed-reviewing-3.jpg" title="Merge box in Pull requests tab" alt="Merge box in Pull requests tab" /></p>
  </li>
  <li>
    <p>병합이 완료된 브랜치는 바로바로 정리해 두는 것이 좋다.
<img src="/images/posts/2023-10-23-Managing-project/merging-code-completed-reviewing-4.jpg" title="Message box to delete merged branch" alt="Message box to delete merged branch" /></p>
  </li>
  <li>
    <p>Issues 탭을 확인해 보면 PR의 병합을 통해 자동으로 닫힌 issue를 확인할 수 있다.
<img src="/images/posts/2023-10-23-Managing-project/merging-code-completed-reviewing-5.jpg" title="Issues tab for the remote repository" alt="Issues tab for the remote repository" /></p>
  </li>
</ol>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 태그 기능을 이용하여 버전을 생성해 보고 Github의 Issue, Milestone, Project 기능을 이용하여 프로젝트 관리 방식을 알아보았으며, Pull request를 통한 협업 방식까지 진행해 보았다. 소프트웨어를 협업하여 개발할 때 수많은 크고 작은 문제들이 쌓이고 얽혀서 회복 불가능한 더 큰 문제를 야기시킬 수 있다. Github의 이러한 다양한 기능들을 이용하여 체계적으로 개발을 진행할 경우 이러한 문제들을 미연에 방지할 수 있다.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="Version" /><category term="버전" /><category term="Issue" /><category term="Milestone" /><category term="Pull request" /><category term="git tag" /><summary type="html"><![CDATA[태그를 이용하여 프로젝트의 작업에 버전도 부여해 보고 이슈와 마일스톤을 이용하여 프로젝트를 관리해 보자.]]></summary></entry><entry><title type="html">11. 작업 되돌리기</title><link href="http://localhost:4000/github/2023/10/20/Reverting-working/" rel="alternate" type="text/html" title="11. 작업 되돌리기" /><published>2023-10-20T17:21:37+09:00</published><updated>2023-10-20T17:21:37+09:00</updated><id>http://localhost:4000/github/2023/10/20/Reverting-working</id><content type="html" xml:base="http://localhost:4000/github/2023/10/20/Reverting-working/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#파일-되돌리기" title="Navigate to Reverting file">파일 되돌리기</a>
      <ul>
        <li><a href="#추적-되돌리기" title="Navigate to Reverting tracking">추적 되돌리기</a></li>
        <li><a href="#스테이지-상태-되돌리기" title="Navigate to Reverting stage status">스테이지 상태 되돌리기</a></li>
        <li><a href="#이전-커밋-상태로-되돌리기" title="Navigate to Reverting to last commit">이전 커밋 상태로 되돌리기</a></li>
      </ul>
    </li>
    <li><a href="#커밋-되돌리기" title="Navigate to Reverting commit">커밋 되돌리기</a>
      <ul>
        <li><a href="#reset-명령어" title="Navigate to Reset command">Reset 명령어</a></li>
        <li><a href="#revert-명령어" title="Navigate to Revert command">Revert 명령어</a></li>
      </ul>
    </li>
    <li><a href="#명령-되돌리기" title="Navigate to Reverting to past commands">명령 되돌리기</a>
      <ul>
        <li><a href="#참조-기록의-목록" title="Navigate to List of reference log">참조 기록의 목록</a></li>
        <li><a href="#자세한-참조-기록의-목록" title="Navigate to List of reference log in detail">자세한 참조 기록의 목록</a></li>
        <li><a href="#특정-참조-기록의-상세-정보-확인하기" title="Navigate to Checking detail information of filtered reference log">특정 참조 기록의 상세 정보 확인하기</a></li>
        <li><a href="#특정-명령어의-사용-시점으로-되돌리기" title="Navigate to Reverting to the past command">특정 명령어의 사용 시점으로 되돌리기</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="파일-되돌리기"><span style="color: brown"><strong>파일 되돌리기</strong></span></h4>
<h5 id="추적-되돌리기"><strong>추적 되돌리기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git <span class="nb">rm</span> <span class="nt">-cached</span> &lt;파일명&gt;
</code></pre></div></div>
<ul>
  <li>파일의 <span style="color: #8D4801"><strong>추적 상태를 추적하지 않은 상태로 변경하는</strong></span> 명령어이다. <span style="color: #8D4801"><strong>파일을 추적한 후 커밋하지 않은 상태에서 바로 삭제할 때 사용할 수 있다.</strong></span> 해당 파일을 이미 한 번이라도 커밋했다면 이전 커밋을 기준으로 해당 파일의 삭제 또한 변화된 이력으로 간주하기 때문에 파일이 여전히 추적 상태이면서 삭제된 상태이고 이를 다시 커밋해야 삭제를 완료할 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-rm-cached.jpg" title="Git command to revert the files to untracked status" alt="Git command to revert the files to untracked status" /></li>
</ul>

<p><br /></p>

<h5 id="스테이지-상태-되돌리기"><strong>스테이지 상태 되돌리기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset &lt;파일명&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--mixed</span> HEAD &lt;파일명&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git restore <span class="nt">--staged</span> &lt;파일명&gt;
</code></pre></div></div>
<ul>
  <li>파일의 <span style="color: #8D4801"><strong>스테이지 상태를 스테이징 되지 않은 상태로 변경하는</strong></span> 명령어이다. <span style="color: #8D4801"><strong>HEAD</strong></span>는 “커밋 범위”의 기본값으로 <span style="color: #8D4801"><strong>생략</strong></span>될 수 있다. 또한 <span style="color: #8D4801"><strong>”- -mixed” 옵션</strong></span>은 reset 명령어의 기본 옵션으로 <span style="color: #8D4801"><strong>생략</strong></span>될 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-restore-staged.jpg" title="Git command to revert the files to unstage status" alt="Git command to revert the files to unstage status" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset &lt;커밋 범위&gt; &lt;파일명&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>“커밋 범위”</strong></span>에 원하는 특정 커밋을 지정하여 <span style="color: #8D4801"><strong>지정된 커밋을 기준으로 되돌릴 수 있다.</strong></span>
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-HEAD.jpg" title="Git command to revert the files to unstage status based on given commit scope" alt="Git command to revert the files to unstage status based on given commit scope" /></li>
</ul>

<p><br /></p>

<h5 id="이전-커밋-상태로-되돌리기"><strong>이전 커밋 상태로 되돌리기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">--</span> &lt;파일명&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--hard</span> &lt;파일명&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git restore &lt;파일명&gt;
</code></pre></div></div>
<ul>
  <li>파일을 <span style="color: #8D4801"><strong>바로 이전 커밋 상태 즉, 수정 전 상태로 되돌리는</strong></span> 명령어이다. checkout 명령어는 restore 명령어가 존재하기 전 과거에 사용하던 방법으로 되도록 <span style="color: #8D4801"><strong>restore 명령어 사용을 추천</strong></span>한다. (checkout 명령어는 다른 용도와 목적으로 사용된다.)</li>
  <li>“reset - -hard” 명령어와 restore 명령어는 동일한 결과를 만들어내지만 동작 방식에는 차이가 있을 수 있다. restore 명령어는 파일을 이전 상태로 복원하는 것이라면 “reset - -hard” 명령어는 파일을 이전 커밋의 상태로 되돌리는 것이다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-restore.jpg" title="Git command to restore the files" alt="Git command to restore the files" /></li>
</ul>

<hr />

<h4 id="커밋-되돌리기"><span style="color: brown"><strong>커밋 되돌리기</strong></span></h4>
<h5 id="reset-명령어"><strong>Reset 명령어</strong></h5>
<p>지정된 커밋으로 되돌아가는 명령어이다. 즉, <span style="color: #8D4801"><strong>특정 커밋의 상태로 모든 코드를 복구하고 되돌아간 만큼의 커밋을 취소</strong></span>한다. 이미 <span style="color: indianred"><strong>공유된 커밋 내역을 리셋할 경우 협업 중인 동료들에게 혼돈을 줄 수 있으므로 주의</strong></span>해야 한다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset &lt;옵션&gt; &lt;커밋 범위&gt;
</code></pre></div></div>
<center><img src="/images/posts/2023-10-20-Reverting-working/reference-of-reset-command.webp" title="Reference of reset command" alt="Reference of reset command" /></center>

<ul>
  <li><strong>soft 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--soft</span> &lt;커밋 범위&gt;
</code></pre></div>    </div>
    <ul>
      <li>취소된 커밋 기록의 <span style="color: #8D4801"><strong>스테이지 상태까지 복원</strong></span>하는 옵션이다.</li>
      <li>취소된 커밋 기록을 커밋 직전인 스테이지 상태로 복원하기 때문에 마지막 커밋으로 이 옵션을 이용하여 리셋할 경우 <span style="color: #8D4801"><strong>“git commit - -amend” 명령어와 유사하게 작업</strong></span>할 수 있다.</li>
      <li>여러 개의 커밋을 이 옵션을 이용하여 리셋하고 다시 커밋할 경우 하나의 커밋이 생성되므로 <span style="color: #8D4801"><strong>여러 개의 커밋을 하나로 합치는 것처럼 사용</strong></span>할 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-soft.jpg" title="Git command to reset the commit with soft option" alt="Git command to reset the commit with soft option" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>mixed 옵션 (default)</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--mixed</span> &lt;커밋 범위&gt;
</code></pre></div>    </div>
    <ul>
      <li>Reset 명령어의 <span style="color: #8D4801"><strong>기본 옵션</strong></span>으로 따로 옵션을 설정하지 않으면 이 옵션으로 실행되므로 옵션을 생략할 수도 있다. 취소된 커밋 기록을 <span style="color: #8D4801"><strong>작업 디렉토리로 복원</strong></span>하는 옵션이다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-mixed.jpg" title="Git command to reset the commit with mixed option" alt="Git command to reset the commit with mixed option" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>hard 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--hard</span> &lt;커밋 범위&gt;
</code></pre></div>    </div>
    <ul>
      <li>취소된 커밋 기록을 <span style="color: #8D4801"><strong>모두 삭제</strong></span>하는 옵션이다. <span style="color: indianred"><strong>지금까지의 모든 작업 내용을 삭제하므로 주의하여 사용하여야 한다.</strong></span></li>
      <li>기본값인 HEAD 커밋으로 이 옵션을 이용하여 리셋할 경우 지금까지의 작업을 모두 삭제할 수 있으므로 <span style="color: #8D4801"><strong>진행 중인 작업을 깔끔하게 취소하고 싶을 때 사용</strong></span>할 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-hard.jpg" title="Git command to reset the commit with hard option" alt="Git command to reset the commit with hard option" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>병합 취소하기</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--merge</span> HEAD~
</code></pre></div>    </div>
    <ul>
      <li>
        <p><span style="color: #8D4801"><strong>3-way 병합 커밋을 취소</strong></span>하고 병합 이전의 상태로 돌아간다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-20-Reverting-working/before-git-command-reset-merge.jpg" title="Git log before git command reset --merge" alt="Git log before git command reset --merge" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-merge.jpg" title="Git command to reset merge commit" alt="Git command to reset merge commit" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-20-Reverting-working/after-git-command-reset-merge.jpg" title="Git log after git command reset --merge" alt="Git log after git command reset --merge" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="revert-명령어"><strong>Revert 명령어</strong></h5>
<p>기존의 커밋을 취소하는 Reset 명령어와 달리, Revert 명령어는 <span style="color: #8D4801"><strong>기존 커밋을 보존하면서 되돌리기 작업에 대한 새로운 커밋을 생성</strong></span>한다. 그래서 명령어를 실행했을 때 새로운 커밋에 대한 에디터가 실행된다. <span style="color: indianred"><strong>복귀를 위한 커밋이 지속해서 생기면 커밋 이력이 복잡해질 수 있으므로 회사의 Convention이나 상황에 맞게 주의하여 사용</strong></span>해야 한다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert &lt;커밋 해시값&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-20-Reverting-working/before-git-command-revert.jpg" title="Git log before git command revert" alt="Git log before git command revert" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert.jpg" title="Git command to revert the commit" alt="Git command to revert the commit" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-20-Reverting-working/after-git-command-revert.jpg" title="Git log after git command revert" alt="Git log after git command revert" /></p>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>범위 지정 Revert</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert &lt;커밋 해시값&gt;..&lt;커밋 해시값&gt;
</code></pre></div>    </div>
    <ul>
      <li>
        <p>기본적으로 Revert 명령어는 <span style="color: #8D4801"><strong>한 번에 커밋 단 하나만 취소</strong></span>할 수 있다. 만약 <span style="color: #8D4801"><strong>범위 지정 연산자를 사용할 경우 범위 안의 여러 개의 커밋을 취소</strong></span>할 수 있다. 이때 더 최근의 커밋을 뒤에 입력해야 한다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-20-Reverting-working/before-git-command-revert-commit-range.jpg" title="Git log before git command revert range of commits" alt="Git log before git command revert range of commits" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert-commit-range.jpg" title="Git command to revert range of commits" alt="Git command to revert range of commits" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-20-Reverting-working/after-git-command-revert-commit-range.jpg" title="Git log after git command revert range of commits" alt="Git log after git command revert range of commits" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Revert 진행 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert <span class="nt">--continue</span>
</code></pre></div>    </div>
    <ul>
      <li>Revert 명령어는 새로운 커밋을 생성하기 때문에 병합이나 리베이스와 같이 충돌이 발생할 수 있다. 현재 진행 중인 <span style="color: #8D4801"><strong>되돌리기를 계속 진행</strong></span>하는 옵션으로 충돌 등이 발생했을 때 문제 해결 후 되돌리기를 계속 진행하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert-continue.jpg" title="Git command to continue reverting" alt="Git command to continue reverting" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Revert 건너뛰기 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert <span class="nt">--skip</span>
</code></pre></div>    </div>
    <ul>
      <li>되돌리기 중 충돌 등이 발생한 경우 문제 해결 중에 <span style="color: #8D4801"><strong>특정 커밋의 충돌을 건너뛰고 되돌리기를 진행</strong></span>하고 싶을 경우 사용하는 옵션이다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert-skip.jpg" title="Git command to skip reverting" alt="Git command to skip reverting" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Revert 중지 옵션</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert <span class="nt">--abort</span>
</code></pre></div>    </div>
    <ul>
      <li>현재 진행 중인 <span style="color: #8D4801"><strong>되돌리기를 중지</strong></span>하는 옵션으로 충돌 등이 발생했을 때 되돌리기를 중지하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert-abort.jpg" title="Git command to abort reverting" alt="Git command to abort reverting" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>병합 취소 Revert</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert <span class="nt">-m</span> &lt;숫자&gt; &lt;병합 커밋 해시값&gt;
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git revert <span class="nt">--mainline</span> &lt;숫자&gt; &lt;병합 커밋 해시값&gt;
</code></pre></div>    </div>
    <ul>
      <li>
        <p>되돌리기 작업에 대한 새로운 커밋을 생성하는 Revert 명령어의 특성상 <span style="color: #8D4801"><strong>병합 커밋을 되돌릴 때 어느 브랜치의 내용으로 복귀할지 모호성</strong></span>이 생긴다. 이런 경우에 이 옵션을 사용하여 <span style="color: #8D4801"><strong>복귀할 브랜치의 내용을 선택</strong></span>할 수 있다. <span style="color: #8D4801"><strong>숫자</strong></span>는 아래 이미지와 같이 <span style="color: #8D4801"><strong>좌측부터 1로 시작</strong></span>한다.</p>
      </li>
      <li>
        <p>명령어 실행 전
<img src="/images/posts/2023-10-20-Reverting-working/before-git-command-revert-mainline.jpg" title="Git log before git command revert --mainline" alt="Git log before git command revert --mainline" /></p>
      </li>
      <li>
        <p>명령어 실행
<img src="/images/posts/2023-10-20-Reverting-working/git-command-revert-mainline.jpg" title="Git command to revert merge commit" alt="Git command to revert merge commit" /></p>
      </li>
      <li>
        <p>명령어 실행 후
<img src="/images/posts/2023-10-20-Reverting-working/after-git-command-revert-mainline.jpg" title="Git log after git command revert --mainline" alt="Git log after git command revert --mainline" /></p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="명령-되돌리기"><span style="color: brown"><strong>명령 되돌리기</strong></span></h4>
<p>앞에서는 작업을 되돌리는 명령어를 알아보았다면 이번에는 <span style="color: #8D4801"><strong>실수로 실행한 명령어를 되돌리는 방법</strong></span>을 알아보자.</p>

<h5 id="참조-기록의-목록"><strong>참조 기록의 목록</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reflog
</code></pre></div></div>
<ul>
  <li>우리는 이미 Git의 몇 가지 포인터들을 알고 있다. 가장 최근 커밋을 가리키는 HEAD, 브랜치의 마지막 커밋을 가리키는 브랜치 포인터, 배포 관리를 위해 생성하는 태그 포인터 등 이러한 포인터들은 특정 커밋을 참조하고 있으며 우리가 실행하는 명령어에 따라서 이동, 수정된다. 이 명령어는 위의 <span style="color: #8D4801"><strong>참조들에 대하여 수행된 명령어의 기록을 목록으로 확인</strong></span>할 수 있는 명령어이다.</li>
  <li>참조 기록은 <span style="color: indianred"><strong>영구적이지 않고 시스템에 설정된 일정 기간만 보관</strong></span>하다가 삭제된다. 또한 참조 기록은 오로지 <span style="color: indianred"><strong>로컬 저장소에만 존재하며 복사, 이동 등으로 기록을 옮길 수 없다.</strong></span>
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reflog.jpg" title="Git command to show list of reference log" alt="Git command to show list of reference log" /></li>
</ul>

<p><br /></p>

<h5 id="자세한-참조-기록의-목록"><strong>자세한 참조 기록의 목록</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">-g</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-10-20-Reverting-working/git-command-log-g.jpg" title="Git command to show list of reference log in detail" alt="Git command to show list of reference log in detail" /></p>

<p><br /></p>

<h5 id="특정-참조-기록의-상세-정보-확인하기"><strong>특정 참조 기록의 상세 정보 확인하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git show &lt;레퍼런스 이름&gt;@<span class="o">{</span>&lt;필터&gt;<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>레퍼런스 이름</strong></span>에는 HEAD, 브랜치 이름, 태그 이름 등을 사용할 수 있다.</li>
  <li><span style="color: #8D4801"><strong>필터 옵션</strong></span>
    <ul>
      <li><span style="color: #8D4801"><strong>커밋의 상대적인 위치</strong></span>
        <ul>
          <li>현재 커밋인 <span style="color: #8D4801"><strong>0</strong></span>을 기준으로 <span style="color: #8D4801"><strong>n</strong></span>번째 이전의 커밋을 뜻한다. 예를 들어 “HEAD@{1}”은 현재 커밋으로부터 바로 이전의 커밋을 뜻한다.</li>
          <li><span style="color: indianred"><strong>여기서 커밋은 작업 영역의 커밋이 아닌 참조 기록에 대한 커밋이다.</strong></span></li>
        </ul>
      </li>
      <li><span style="color: #8D4801"><strong>날짜</strong></span>
        <ul>
          <li><span style="color: #8D4801"><strong>YYYY-MM-DD</strong></span>: 2023-01-01과 같이 특정 날짜의 커밋을 뜻하는 옵션으로 Git에서 공식적으로 정의된 필터 형식이다. 이외에 Git은 상대적인 시간 표현을 인식하여 동작하기 때문에 아래와 같은 비공식적인 필터 형식들 또한 사용할 수 있다.</li>
          <li><span style="color: #8D4801"><strong>yesterday</strong></span>: 어제의 커밋</li>
          <li><span style="color: #8D4801"><strong>1.week.ago</strong></span>: 일주일 전의 커밋
<img src="/images/posts/2023-10-20-Reverting-working/git-command-show-reference-log.jpg" title="Git command to show specified log for filtered reference" alt="Git command to show specified log for filtered reference" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="특정-명령어의-사용-시점으로-되돌리기"><strong>특정 명령어의 사용 시점으로 되돌리기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--hard</span> &lt;레퍼런스 이름&gt;@<span class="o">{</span>&lt;커밋의 상대적인 위치&gt;<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>
    <p>참조 기록의 목록에서 확인한 특정 커밋으로 되돌아가는 명령어로써, 실행하면 현재 브랜치에서 지정한 커밋의 <span style="color: #8D4801"><strong>명령어를 사용했던 시점으로 모든 커밋과 작업 내용을 되돌린다.</strong></span> 일반적으로 <span style="color: indianred"><strong>자신의 작업 실수를 바로잡을 때 최후의 수단으로 사용하는 것을 추천</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-20-Reverting-working/before-git-command-reset-hard-ref-commit.jpg" title="Git reference log before git command reset --hard &lt;ref&gt;@{commit}" alt="Git reference log before git command reset --hard &lt;ref&gt;@{commit}" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-20-Reverting-working/git-command-reset-hard-ref-commit.jpg" title="Git command to reset to the reference commit" alt="Git command to reset to the reference commit" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-20-Reverting-working/after-git-command-reset-hard-ref-commit.jpg" title="Git reference log after git command reset --hard &lt;ref&gt;@{commit}" alt="Git reference log after git command reset --hard &lt;ref&gt;@{commit}" /></p>
  </li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 여러 가지 상황에서 진행 중이던 상태를 되돌리는 방법을 알아보았다. 이제 일반적인 개발자가 Git에서 작업할 때 꼭 알아야 할 명령어들은 대부분 알아본 것이다. 다음 포스트에서는 협업 시 관리자에게 나의 작업을 병합 요청하는 Pull request에 대하여 알아보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git rm" /><category term="git restore" /><category term="git reset" /><category term="git revert" /><category term="git reflog" /><summary type="html"><![CDATA[Git 저장소에서 작업을 하다 보면 지금까지 한 작업을 취소하고 다시 시작해야 할 경우가 있다. 이런 경우에 필요한 복귀 명령어를 알아보자.]]></summary></entry><entry><title type="html">10. 병합과 리베이스</title><link href="http://localhost:4000/github/2023/10/14/Merge-and-rebase/" rel="alternate" type="text/html" title="10. 병합과 리베이스" /><published>2023-10-14T11:49:32+09:00</published><updated>2023-10-14T11:49:32+09:00</updated><id>http://localhost:4000/github/2023/10/14/Merge-and-rebase</id><content type="html" xml:base="http://localhost:4000/github/2023/10/14/Merge-and-rebase/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#base-commit" title="Navigate to Base commit">Base commit</a></li>
    <li><a href="#병합이란" title="Navigate to What is merge?">병합이란?</a>
      <ul>
        <li><a href="#fast-forward-병합" title="Navigate to Fast-forward merge">Fast-forward 병합</a></li>
        <li><a href="#3-way-병합" title="Navigate to Three-way merge">3-way 병합</a></li>
        <li><a href="#병합-명령어" title="Navigate to Command to merge">병합 명령어</a></li>
        <li><a href="#병합-중지-옵션" title="Navigate to Option to abort merge">병합 중지 옵션</a></li>
        <li><a href="#병합-진행-옵션" title="Navigate to Option to continue merge">병합 진행 옵션</a></li>
      </ul>
    </li>
    <li><a href="#리베이스란" title="Navigate to What is rebase?">리베이스란?</a>
      <ul>
        <li><a href="#리베이스-명령어" title="Navigate to Command to rebase">리베이스 명령어</a></li>
        <li><a href="#범위-지정-리베이스" title="Navigate to Command to rebase with setting scope">범위 지정 리베이스</a></li>
        <li><a href="#리베이스-진행-옵션" title="Navigate to Option to continue rebase">리베이스 진행 옵션</a></li>
        <li><a href="#리베이스-건너뛰기-옵션" title="Navigate to Option to skip rebase">리베이스 건너뛰기 옵션</a></li>
        <li><a href="#리베이스-중지-옵션" title="Navigate to Option to abort rebase">리베이스 중지 옵션</a></li>
        <li><a href="#대화형-리베이스" title="Navigate to Interactive rebase">대화형 리베이스</a></li>
      </ul>
    </li>
    <li><a href="#병합과-리베이스의-차이점" title="Navigate to Difference between merge and rebase">병합과 리베이스의 차이점</a>
      <ul>
        <li><a href="#-헷갈리기-쉬운-명령어의-방향" title="Navigate to Direction of command that easily confused">헷갈리기 쉬운 명령어의 방향</a></li>
      </ul>
    </li>
    <li><a href="#체리픽이란" title="Navigate to What is cherry-pick?">체리픽이란?</a>
      <ul>
        <li><a href="#체리픽-명령어" title="Navigate to Command cherry-pick">체리픽 명령어</a></li>
        <li><a href="#체리픽-진행-옵션" title="Navigate to Option to continue cherry-pick">체리픽 진행 옵션</a></li>
        <li><a href="#체리픽-건너뛰기-옵션" title="Navigate to Option to skip cherry-pick">체리픽 건너뛰기 옵션</a></li>
        <li><a href="#체리픽-중지-옵션" title="Navigate to Option to abort cherry-pick">체리픽 중지 옵션</a></li>
      </ul>
    </li>
    <li><a href="#충돌과-해결-방법" title="Navigate to Conflict and solution for">충돌과 해결 방법</a>
      <ul>
        <li><a href="#충돌이란" title="Navigate to What is conflict?">충돌이란?</a></li>
        <li><a href="#해결-방법" title="Navigate to Solution for conflict">해결 방법</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="base-commit"><span style="color: brown"><strong>Base commit</strong></span></h4>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-base-commit.webp" title="Reference of base commit" alt="Reference of base commit" /></center>
<ul>
  <li>Base 커밋이란 한국어로 공통 조상 커밋이라고 표현할 수 있으며 <span style="color: #8D4801"><strong>두 개 이상의 브랜치나 커밋이 공유하는 최신 공통 커밋</strong></span>을 의미한다. 주로 병합 및 리베이스의 기준 역할을 한다.</li>
</ul>

<hr />

<h4 id="병합이란"><span style="color: brown"><strong>병합이란?</strong></span></h4>
<p><span style="color: #8D4801"><strong>Base 커밋을 기준으로 현재 작업 중인 브랜치에 지정된 브랜치의 커밋을 모두 통합하는</strong></span> 것이다. 이러한 병합에는 <span style="color: #8D4801"><strong>두 가지 방식</strong></span>이 존재한다.</p>

<h5 id="fast-forward-병합"><strong>Fast-forward 병합</strong></h5>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-fast-forward-merge.webp" title="Reference of Fast-forward merge" alt="Reference of Fast-forward merge" /></center>
<ul>
  <li>위의 그림과 같이 <span style="color: #8D4801"><strong>현재 작업 중인 브랜치의 최신 커밋이 병합을 지정한 브랜치의 시작 커밋과 연결</strong></span>되어있을 경우 브랜치가 분기되어 있지만 마치 <span style="color: #8D4801"><strong>순차적</strong></span>으로 생성된 커밋의 흐름처럼 보인다. 이런 경우엔 <span style="color: #8D4801"><strong>새로운 병합 커밋을 생성하지 않고 현재 작업 중인 브랜치의 HEAD를 병합을 지정한 브랜치의 최신 커밋으로 이동</strong></span>만 시키는데 이러한 병합 방식을 <span style="color: #8D4801"><strong>Fast-forward 병합</strong></span>이라고 한다.</li>
  <li>일반적으로 <span style="color: #8D4801"><strong>혼자</strong></span> 프로젝트를 진행할 경우 접하게 되는 병합 방식이다.</li>
</ul>

<p><br /></p>

<h5 id="3-way-병합"><strong>3-way 병합</strong></h5>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-three-way-merge.webp" title="Reference of Three-way merge" alt="Reference of Three-way merge" /></center>
<ul>
  <li>위의 그림과 같이 base 커밋을 기준으로 <span style="color: #8D4801"><strong>세 종류의 서로 다른 커밋들</strong></span>을 현재 작업 중인 브랜치에 <span style="color: #8D4801"><strong>새로운 하나의 커밋으로 병합</strong></span>하는 방식을 <span style="color: #8D4801"><strong>3-way 병합</strong></span>이라고 한다.</li>
  <li><span style="color: #8D4801"><strong>다수의 개발자와 협업</strong></span>하여 프로젝트를 진행할 경우 접하게 되는 병합 방식이다.</li>
  <li>새로운 병합 커밋은 <span style="color: #8D4801"><strong>두 개의 부모 커밋</strong></span>을 가지며, 커밋을 생성할 때 언제나 그랬듯이 병합 커밋을 생성할 때도 <span style="color: #8D4801"><strong>커밋 메시지를 작성</strong></span>해야한다.</li>
</ul>

<p><br /></p>

<h5 id="병합-명령어"><strong>병합 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge &lt;파생 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>merge 명령어는 <span style="color: #8D4801"><strong>현재 작업 중인 원본 브랜치</strong></span>를 기준으로 <span style="color: #8D4801"><strong>지정된 파생 브랜치</strong></span>의 커밋을 병합하여 가져오는 것이다. 그러므로 명령어 사용 시 <span style="color: #8D4801"><strong>대상이 되는 원본 브랜치로 switch 명령어로 이동 후 merge 명령어에 파생 브랜치 이름을 입력하여 실행</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-14-Merge-and-rebase/before-git-command-merge.jpg" title="Git log before git command merge" alt="Git log before git command merge" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-merge.jpg" title="Git command to merge target branch into working branch" alt="Git command to merge target branch into working branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-14-Merge-and-rebase/after-git-command-merge.jpg" title="Git log after git command merge" alt="Git log after git command merge" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="병합-진행-옵션"><strong>병합 진행 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge <span class="nt">--continue</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>병합을 계속 진행</strong></span>하는 옵션으로 충돌 등이 발생했을 때 문제 해결 후 병합을 계속 진행하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-merge-continue.jpg" title="Git command to continue merging" alt="Git command to continue merging" /></li>
</ul>

<p><br /></p>

<h5 id="병합-중지-옵션"><strong>병합 중지 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge <span class="nt">--abort</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>병합을 중지</strong></span>하는 옵션으로 충돌 등이 발생했을 때 병합을 중지하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-merge-abort.jpg" title="Git command to abort merging" alt="Git command to abort merging" /></li>
</ul>

<hr />

<h4 id="리베이스란"><span style="color: brown"><strong>리베이스란?</strong></span></h4>
<p>말 그대로 <span style="color: #8D4801"><strong>base 커밋을 다시 설정하는 것</strong></span>으로 <span style="color: #8D4801"><strong>지정된 브랜치의 base 커밋을 최신 커밋으로 이동</strong></span>시키는데, 과거 base 커밋과 연결되어 있던 <span style="color: #8D4801"><strong>현재 작업 중인 브랜치 또한 이동한 새로운 base 커밋으로 연결</strong></span>된다. 또한 현재 작업 중인 브랜치의 이동한 커밋들의 <span style="color: indianred"><strong>해시값</strong></span>은 <span style="color: indianred"><strong>모두 변경</strong></span>된다. Interactive 옵션을 사용 시 <span style="color: indianred"><strong>커밋의 순서와 위치까지도 변경</strong></span>할 수 있으며 <span style="color: indianred"><strong>이는 저장소가 공개된 경우 다른 개발자들과의 협업 시 혼돈을 야기시킬 수 있기 때문에 사용에 유의</strong></span>해야한다.</p>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-rebase.webp" title="Reference of rebase" alt="Reference of rebase" /></center>

<p><br /></p>

<h5 id="리베이스-명령어"><strong>리베이스 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase &lt;목적 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>rebase 명령어는 <span style="color: #8D4801"><strong>현재 작업 중인 브랜치</strong></span>를 기준으로 <span style="color: #8D4801"><strong>지정된 목적 브랜치</strong></span>를 리베이스한다. 이것은 현재 작업 중인 브랜치의 커밋을 목적 브랜치의 최신 커밋 위에 다시 적용하는 것을 의미한다. 따라서 명령어 사용 시 <span style="color: #8D4801"><strong>목적 브랜치에 적용하고자 하는 브랜치로 switch 명령어로 이동 후 rebase 명령어에 목적 브랜치 이름을 입력하여 실행</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-14-Merge-and-rebase/before-git-command-rebase.jpg" title="Git log before git command rebase" alt="Git log before git command rebase" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase.jpg" title="Git command to rebase target branch to working branch" alt="Git command to rebase target branch to working branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-14-Merge-and-rebase/after-git-command-rebase.jpg" title="Git log after git command rebase" alt="Git log after git command rebase" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="범위-지정-리베이스"><strong>범위 지정 리베이스</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase &lt;목적 브랜치 이름&gt; &lt;리베이스 기준점&gt;
</code></pre></div></div>
<ul>
  <li>리베이스 기준점에 입력되는 <span style="color: #8D4801"><strong>특정 범위의 커밋에 목적 브랜치를 리베이스</strong></span>할 수 있다. 리베이스 기준점에 <span style="color: #8D4801"><strong>브랜치 이름을 입력</strong></span>할 경우 <span style="color: #8D4801"><strong>현재 작업 중인 브랜치와 관계없이 rebase 명령을 수행</strong></span>할 수 있다. 따라서 <span style="color: #8D4801"><strong>브랜치를 이동할 필요 없이 rebase를 실행</strong></span>할 수 있다. <span style="color: #8D4801"><strong>리베이스 기준점</strong></span>에는 아래의 <span style="color: #8D4801"><strong>커밋 범위</strong></span>에 해당하는 요소들이 들어갈 수 있다.</li>
  <li><strong>커밋 범위</strong>
    <ul>
      <li><strong>브랜치 이름</strong>: 특정 브랜치의 최신 커밋을 참조할 수 있다.</li>
      <li><strong>태그명</strong>: 특정 태그가 가리키는 커밋을 지정할 수 있다.</li>
      <li><strong>상대 참조</strong>: 상대 참조를 사용하여 현재 위치에서 상대적인 커밋을 가리킬 수 있다. HEAD, HEAD~, HEAD^와 같은 상대 참조를 사용할 수 있다.</li>
      <li><strong>SHA-1 해시값</strong>: 각 커밋에 대해 고유한 해시값을 사용하여 특정 커밋을 지정할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-with-specified-scope.jpg" title="Git command to rebase target branch to specified scope" alt="Git command to rebase target branch to specified scope" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">--onto</span> &lt;목적 브랜치 이름&gt; &lt;리베이스 기준점&gt; &lt;커밋 범위&gt;
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>다른 기준점에 특정 범위의 커밋</strong></span>에 <span style="color: #8D4801"><strong>목적 브랜치를 리베이스할 경우</strong></span>에 사용하는 옵션으로 예를 들어 리베이스 기준점에 브랜치 이름을 입력하고 커밋 범위를 지정하여 현재 작업 중인 브랜치가 아닌 다른 브랜치의 특정 범위의 커밋에 목적 브랜치를 리베이스 하도록 명령할 수 있다. 즉, <span style="color: #8D4801"><strong>좀 더 자세한 특정 커밋들을 리베이스 하기 위한 옵션</strong></span>이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-14-Merge-and-rebase/before-git-command-rebase-onto.jpg" title="Git log before git command rebase --onto" alt="Git log before git command rebase --onto" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-onto.jpg" title="Git command to rebase target branch to rebase starting point within commit scope" alt="Git command to rebase target branch to rebase starting point within commit scope" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-14-Merge-and-rebase/after-git-command-rebase-onto.jpg" title="Git log after git command rebase --onto" alt="Git log after git command rebase --onto" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="리베이스-진행-옵션"><strong>리베이스 진행 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">--continue</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>리베이스를 계속 진행</strong></span>하는 옵션으로 충돌 등이 발생했을 때 문제 해결 후 리베이스를 계속 진행하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-continue.jpg" title="Git command to continue rebasing" alt="Git command to continue rebasing" /></li>
</ul>

<p><br /></p>

<h5 id="리베이스-건너뛰기-옵션"><strong>리베이스 건너뛰기 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">--skip</span>
</code></pre></div></div>
<ul>
  <li>리베이스 중 충돌 등이 발생한 경우 병합과 다르게 <span style="color: #8D4801"><strong>각 커밋별로 문제를 해결해야 한다.</strong></span> 문제 해결 중에 <span style="color: #8D4801"><strong>특정 커밋의 충돌을 건너뛰고 리베이스를 진행</strong></span>하고 싶을 경우 사용하는 옵션이다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-skip.jpg" title="Git command to skip rebasing" alt="Git command to skip rebasing" /></li>
</ul>

<p><br /></p>

<h5 id="리베이스-중지-옵션"><strong>리베이스 중지 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">--abort</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>리베이스를 중지</strong></span>하는 옵션으로 충돌 등이 발생했을 때 리베이스를 중지하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-abort.jpg" title="Git command to abort rebasing" alt="Git command to abort rebasing" /></li>
</ul>

<p><br /></p>

<h5 id="대화형-리베이스"><strong>대화형 리베이스</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">-i</span> &lt;커밋 범위&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">--interactive</span> &lt;커밋 범위&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>사용자가 직접 커밋의 목록을 수정하여 리베이스를 실행</strong></span>하는 옵션이다. 실행 시 에디터가 열리고 사용자가 수동으로 명령어를 사용하여 커밋 분할, 합치기, 재배치 등이 가능하고 커밋 메시지 또한 수정할 수 있다.</li>
  <li><span style="color: #8D4801"><strong>다양한 옵션</strong></span>이 존재하나 몇 가지만 간단히 알아보자.
    <ul>
      <li><span style="color: #8D4801"><strong>pick</strong></span>: 해당 커밋을 그대로 적용한다.</li>
      <li><span style="color: #8D4801"><strong>edit</strong></span>: 해당 커밋을 적용하고, 그 이후의 커밋들을 수정할 수 있도록 중단한다.</li>
      <li><span style="color: #8D4801"><strong>squash</strong></span>: 해당 커밋을 이전 커밋과 합친다.</li>
      <li><span style="color: #8D4801"><strong>exec</strong></span>: 해당 커밋을 적용하기 전에 지정된 명령을 실행한다.</li>
      <li><span style="color: #8D4801"><strong>drop</strong></span>: 해당 커밋을 건너뛴다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-rebase-i.jpg" title="Git command to rebase interactively" alt="Git command to rebase interactively" /></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="병합과-리베이스의-차이점"><span style="color: brown"><strong>병합과 리베이스의 차이점</strong></span></h4>
<p><span style="color: #8D4801"><strong>병합</strong></span>은 내부적으로 현재 작업 중인 브랜치와 지정된 브랜치의 각 커밋들을 순차적으로 비교(<span style="color: deeppink"><strong>그림 1, 2번 과정</strong></span>)하여 최종적으로 병합 커밋을 생성한다.(<span style="color: deeppink"><strong>그림 3번 과정</strong></span>) 즉, 충돌이 발생할 경우 모든 커밋의 비교가 완료된 후에 <span style="color: #8D4801"><strong>한 번에 충돌을 해결하고 병합 커밋을 생성</strong></span>한다.</p>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/example-flow-of-merge.webp" title="Flow of merge to compare with rebase" alt="Flow of merge to compare with rebase" /></center>

<p><br /></p>

<p><span style="color: #8D4801"><strong>리베이스</strong></span>는 두 브랜치를 비교하지 않으며 현재 작업 중인 브랜치의 각 커밋을 순차적으로 목적 브랜치에 병합 시도한다.(<span style="color: deeppink"><strong>그림 1, 2번 과정</strong></span>) 즉, 충돌이 발생할 경우 <span style="color: #8D4801"><strong>각 커밋을 병합할 때마다 충돌을 해결</strong></span>하여 커밋을 생성하고 rebase를 continue하여 다음 커밋의 병합을 시작하는 식으로 <span style="color: #8D4801"><strong>반복 실행</strong></span>한다. 리베이스를 통해 <span style="color: #8D4801"><strong>이동한 커밋들의 해시값이 변하는 이유는 이와 같이 각 커밋을 따로 새로이 병합</strong></span>하기 때문이다.</p>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/example-flow-of-rebase.webp" title="Flow of rebase to compare with merge" alt="Flow of rebase to compare with merge" /></center>

<p><br /></p>

<p><strong>결과적으로</strong> 3-way <span style="color: #8D4801"><strong>병합</strong></span>은 병합에 대한 커밋을 따로 생성하지만 <span style="color: #8D4801"><strong>리베이스</strong></span>는 병합에 대한 커밋을 따로 생성하지 않으며,</p>

<p><span style="color: #8D4801"><strong>병합</strong></span>의 경우 각 브랜치의 HEAD가 기본적으로 최신 커밋을 가리키고 있지만 <span style="color: #8D4801"><strong>리베이스</strong></span>는 목적 브랜치의 HEAD가 최신 커밋이 아니라 변경된 base 커밋을 가리키고 있다.</p>

<h6 id="-헷갈리기-쉬운-명령어의-방향"><span style="color: indianred"><strong>※ 헷갈리기 쉬운 명령어의 방향</strong></span></h6>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/comparison-between-merge-and-rebase.webp" title="Comparing that direction of command between merge and rebase" alt="Comparing that direction of command between merge and rebase" /></center>
<ul>
  <li><span style="color: #8D4801"><strong>main 브랜치</strong></span>로 <span style="color: #8D4801"><strong>jisung 브랜치</strong></span>를 병합하는 상황을 가정해 보자.</li>
  <li>병합의 경우엔 <span style="color: #8D4801"><strong>main 브랜치로 이동해서 jisung 브랜치의 병합을 명령</strong></span>하고
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch main
git merge jisung
</code></pre></div>    </div>
  </li>
  <li>리베이스의 경우엔 <span style="color: #8D4801"><strong>jisung 브랜치로 이동해서 main 브랜치의 리베이스를 명령</strong></span>한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch jisung
git rebase main
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="체리픽이란"><span style="color: brown"><strong>체리픽이란?</strong></span></h4>
<p>체리나 과일에서 <span style="color: #8D4801"><strong>좋은 것만 골라서 선택하는 행위</strong></span>를 뜻하는 단어로 Git에서는 <span style="color: #8D4801"><strong>다른 브랜치에서 선택적으로 원하는 커밋을 골라내어 현재 브랜치로 가져오는</strong></span> 명령어를 의미한다.</p>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-cherry-pick.webp" title="Reference of cherry-pick" alt="Reference of cherry-pick" /></center>

<p><br /></p>

<h5 id="체리픽-명령어"><strong>체리픽 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cherry-pick &lt;커밋 해시값&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-14-Merge-and-rebase/before-git-command-cherry-pick.jpg" title="Git log before git command cherry-pick" alt="Git log before git command cherry-pick" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-cherry-pick.jpg" title="Git command to pick commit optionally to current branch from another branch" alt="Git command to pick commit optionally to current branch from another branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-14-Merge-and-rebase/after-git-command-cherry-pick.jpg" title="Git log after git command cherry-pick" alt="Git log after git command cherry-pick" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="체리픽-진행-옵션"><strong>체리픽 진행 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cherry-pick <span class="nt">--continue</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>체리픽을 계속 진행</strong></span>하는 옵션으로 충돌 등이 발생했을 때 문제 해결 후 체리픽을 계속 진행하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-cherry-pick-continue.jpg" title="Git command to continue proceeding cherry-pick" alt="Git command to continue proceeding cherry-pick" /></li>
</ul>

<p><br /></p>

<h5 id="체리픽-건너뛰기-옵션"><strong>체리픽 건너뛰기 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cherry-pick <span class="nt">--skip</span>
</code></pre></div></div>
<ul>
  <li>체리픽 중 충돌 등이 발생한 경우 문제 해결 중에 <span style="color: #8D4801"><strong>특정 커밋의 충돌을 건너뛰고 체리픽을 진행</strong></span>하고 싶을 경우 사용하는 옵션이다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-cherry-pick-skip.jpg" title="Git command to skip proceeding cherry-pick" alt="Git command to skip proceeding cherry-pick" /></li>
</ul>

<p><br /></p>

<h5 id="체리픽-중지-옵션"><strong>체리픽 중지 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cherry-pick <span class="nt">--abort</span>
</code></pre></div></div>
<ul>
  <li>현재 진행 중인 <span style="color: #8D4801"><strong>체리픽을 중지</strong></span>하는 옵션으로 충돌 등이 발생했을 때 체리픽을 중지하고 싶을 경우 사용할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-cherry-pick-abort.jpg" title="Git command to abort proceeding cherry-pick" alt="Git command to abort proceeding cherry-pick" /></li>
</ul>

<hr />

<h4 id="충돌과-해결-방법"><span style="color: brown"><strong>충돌과 해결 방법</strong></span></h4>
<h5 id="충돌이란"><strong>충돌이란?</strong></h5>
<center><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-conflict.webp" title="Reference of conflict" alt="Reference of conflict" width="70%" /></center>
<ul>
  <li><span style="color: green"><strong>동일한 파일</strong></span>에서 <span style="color: green"><strong>동일한 위치</strong></span>의 코드를 <span style="color: dodgerblue"><strong>두 명 이상이 서로 다르게 수정</strong></span>했을 때 <span style="color: #8D4801"><strong>병합을 시도할 경우 충돌이 발생</strong></span>한다.</li>
  <li>충돌이 발생할 경우 <span style="color: #8D4801"><strong>병합이 중지</strong></span>되고 수동으로 해결할 때까지 <span style="color: #8D4801"><strong>커밋이 생성되지 않는다.</strong></span> 병합이 중지된 경우 “–continue” 옵션으로 병합을 지속하거나 “–abort” 옵션으로 병합을 중단할 수 있다.</li>
  <li>리베이스의 경우엔 “–skip” 옵션을 통해 일부 커밋의 충돌을 무시하고 리베이스를 진행할 수 있다.</li>
</ul>

<p><br /></p>

<h5 id="해결-방법"><strong>해결 방법</strong></h5>
<ol>
  <li>먼저 충돌이 발생한 <span style="color: #8D4801"><strong>파일들을 목록으로 확인</strong></span>한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git ls-files <span class="nt">-u</span>
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git ls-files <span class="nt">--unmerged</span>
</code></pre></div>    </div>
    <ul>
      <li>병합하지 않은 파일들을 출력하는 명령어로 <span style="color: #8D4801"><strong>충돌이 해결되지 않은 파일들의 목록을 확인</strong></span>할 수 있다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/git-command-ls-files-u.jpg" title="Git command to show list of unmerged files" alt="Git command to show list of unmerged files" /></li>
      <li><strong>목록의 파일 실행 방법</strong>
        <ul>
          <li>목록의 파일 위에 커서를 올려두고 <span style="color: #8D4801"><strong>“command 버튼 + 클릭”</strong></span>하여 해당 파일을 실행</li>
          <li>아래와 같은 <span style="color: #8D4801"><strong>에디터 실행 명령어</strong></span>로 해당 파일을 실행</li>
          <li>
            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim &lt;파일 경로&gt;
</code></pre></div>            </div>
            <p><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-vim-editor.jpg" title="Reference of vim editor" alt="Reference of vim editor" width="70%" /></p>
          </li>
          <li>
            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>code &lt;파일 경로&gt;
</code></pre></div>            </div>
            <p><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-vscode-editor.jpg" title="Reference of vscode editor" alt="Reference of vscode editor" width="70%" /></p>
          </li>
          <li>
            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open <span class="nt">-a</span> Xcode &lt;파일 경로&gt;
</code></pre></div>            </div>
            <p><img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-xcode-editor.jpg" title="Reference of xcode editor" alt="Reference of xcode editor" width="70%" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>목록에서 충돌이 발생한 파일을 실행하면 아래와 같은 <span style="color: #8D4801"><strong>충돌 마커</strong></span>가 생성되어 있다. 에디터를 이용하여 <span style="color: #8D4801"><strong>실제 파일의 코드</strong></span>를 수정해야 한다.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
원본 브랜치의 HEAD가 가리키는 커밋의 내용
<span class="o">=======</span>
파생 브랜치의 diff 내용
<span class="o">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> 브랜치 이름 등의 참조 이름
</code></pre></div>    </div>
    <ul>
      <li>충돌이 발생한 파일의 수정을 완료하기 위해선 생성되어 있는 <span style="color: #8D4801"><strong>충돌 마커를 삭제</strong></span>해야한다. 당연하게도 <span style="color: #8D4801"><strong>충돌한 파일의 내용은 개발자의 적절한 판단하에 수정</strong></span>하여야 한다.
<img src="/images/posts/2023-10-14-Merge-and-rebase/reference-of-resolving-conflicted-file.webp" title="Reference of resolving conflicted file" alt="Reference of resolving conflicted file" width="70%" /></li>
    </ul>
  </li>
  <li>충돌한 모든 파일의 수정이 완료되면 <span style="color: #8D4801"><strong>병합 커밋을 생성</strong></span>하여 <span style="color: #8D4801"><strong>최종적으로 충돌을 해결</strong></span>할 수 있다. 먼저 <span style="color: #8D4801"><strong>add 명령어를 사용</strong></span>하여 수정이 완료된 파일들을 <span style="color: #8D4801"><strong>스테이지 상태</strong></span>로 만든다.
    <ul>
      <li><span style="color: #8D4801"><strong>직접 commit 명령어를 사용</strong></span>하여 commit을 생성할 수 있다.</li>
      <li><span style="color: #8D4801"><strong>병합 또는 리베이스 명령어를 “–continue” 옵션과 함께 사용</strong></span>하여 진행할 경우 충돌 해결이 완료된 상태일 때 자동으로 commit을 생성한다.</li>
    </ul>
  </li>
</ol>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 병합과 리베이스 그리고 그 도중에 발생할 수 있는 충돌에 대하여 알아보았다. 작성을 시작할 때는 아는 한도 내에서 쉽게 풀어서 작성해 보자고 다짐했는데 막상 읽어보니 쉬운 게 맞나..? 의구심이 들어서 몇 번을 더 수정했던 것 같다. 다음 포스트에서는 작업 중 발생하는 실수를 되돌릴 수 있게 해주는 복구 명령어들을 알아보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git merge" /><category term="git rebase" /><category term="git ls-files" /><summary type="html"><![CDATA[버전 관리의 꽃이라 해도 과언이 아닐 파트이다. 서로 다른 브랜치의 이력을 합쳐도 보고 한쪽 브랜치로 이동도 시켜보고 도중에 충돌이 발생했을 때 조치하는 방법까지 알아보자.]]></summary></entry><entry><title type="html">9. 작업 변경 사항을 Stash 스택에 임시 저장하기</title><link href="http://localhost:4000/github/2023/10/12/Temporary-saving-of-working-status-to-stack/" rel="alternate" type="text/html" title="9. 작업 변경 사항을 Stash 스택에 임시 저장하기" /><published>2023-10-12T14:11:02+09:00</published><updated>2023-10-12T14:11:02+09:00</updated><id>http://localhost:4000/github/2023/10/12/Temporary-saving-of-working-status-to-stack</id><content type="html" xml:base="http://localhost:4000/github/2023/10/12/Temporary-saving-of-working-status-to-stack/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#stash-스택에-저장하기" title="Navigate to Pushing datas to stash">Stash 스택에 저장하기</a>
      <ul>
        <li><a href="#저장-명령어" title="Navigate to Command to stash datas">저장 명령어</a></li>
        <li><a href="#stash-메시지-남기기" title="Navigate to Stash message">Stash 메시지 남기기</a></li>
        <li><a href="#특정-파일들을-선별하여-stash-실행하기" title="Navigate to Distinguish to stash">특정 파일들을 선별하여 stash 실행하기</a></li>
      </ul>
    </li>
    <li><a href="#stash-스택-확인하기" title="Navigate to Checking stash list">Stash 스택 확인하기</a>
      <ul>
        <li><a href="#stash-목록-확인하기" title="Navigate to Command to check stash list">Stash 목록 확인하기</a></li>
        <li><a href="#작업-영역과-stash-사이의-차이점-비교-명령어" title="Navigate to Command to compare difference between working directory and stash">작업 영역과 stash 사이의 차이점 비교 명령어</a></li>
      </ul>
    </li>
    <li><a href="#stash-스택에서-작업-꺼내기" title="Navigate to Popping datas from stash">Stash 스택에서 작업 꺼내기</a>
      <ul>
        <li><a href="#저장된-작업-꺼내기" title="Navigate to Popping stashed datas">저장된 작업 꺼내기</a></li>
        <li><a href="#새로운-브랜치-생성하면서-저장된-작업-꺼내기" title="Navigate to Creating new branch and popping to the branch">새로운 브랜치 생성하면서 저장된 작업 꺼내기</a></li>
        <li><a href="#저장된-작업-불러오기" title="Navigate to Applying stash to working directory">저장된 작업 불러오기</a></li>
      </ul>
    </li>
    <li><a href="#stash-삭제하기" title="Navigate to Dropping datas in stash">Stash 삭제하기</a>
      <ul>
        <li><a href="#stash-하나-삭제하기" title="Navigate to Dropping a stash">Stash 하나 삭제하기</a></li>
        <li><a href="#모든-stash-삭제하기" title="Navigate to Clearing all stashes">모든 stash 삭제하기</a></li>
      </ul>
    </li>
    <li><a href="#작업-영역-정리하기" title="Navigate to Cleaning working directory">작업 영역 정리하기</a></li>
  </ol>
</blockquote>

<hr />

<h4 id="들어가기-전에">들어가기 전에</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--allow-empty-message</span> <span class="nt">-m</span> <span class="s2">""</span>

<span class="o">(</span> 다른 브랜치 이동 <span class="o">)</span>

<span class="o">(</span> 기존 브랜치 복귀 <span class="o">)</span>

git reset HEAD^
</code></pre></div></div>
<p>Stash란 안전한 곳에 넣어 둔다는 의미를 지닌다. Git에서 작업을 하다 보면 피치 못하게 브랜치를 이동해야 하는 상황이 생긴다. 하지만 이동할 때마다 commit하고 용무가 끝난 뒤 다시 돌아와서 reset을 하는 것은 과정도 복잡할뿐더러 불편하다. 이러한 경우에 필요한 명령어가 stash이다. <span style="color: #8D4801"><strong>작업 중이던 수정 내용들을 잠시 안전한 곳에 넣어두었다가 필요할 때 다시 꺼내어 사용</strong></span>할 수 있다.</p>
<div class="image-slider-static">
  <img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/stash-in-naver-dictionary.jpg" title="Definition of stash in Naver dictionary" alt="Definition of stash in Naver dictionary" />
</div>

<center>
  <a href="https://en.dict.naver.com/#/entry/enko/02ccbc67c89343d4b88048c8b25d5464" title="Navigate to Naver dictionary">
    <small><i class="fa fa-copyright" aria-hidden="true"></i>네이버 사전</small>
  </a>
</center>
<p><br /></p>

<hr />

<h4 id="stash-스택에-저장하기"><span style="color: brown"><strong>Stash 스택에 저장하기</strong></span></h4>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash.webp" title="Diagram showing flow of git command stash" alt="Diagram showing flow of git command stash" /></center>

<p><br /></p>

<h5 id="저장-명령어"><strong>저장 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash save
</code></pre></div></div>
<ul>
  <li>
    <p><a href="#들어가기-전에" title="Navigate to Preface">위의</a> 복잡한 과정을 한 번에 해결해 주는 명령어이다. <span style="color: #8D4801"><strong>작업 영역의 변경 사항들을 stash 스택에 저장하고 작업 영역을 깨끗이 정리</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash.webp" title="Stash list before git command stash" alt="Stash list before git command stash" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash.webp" title="Git command to save working changes temporarily into stash stack" alt="Git command to save working changes temporarily into stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash.webp" title="Stash list after git command stash" alt="Stash list after git command stash" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="stash-메시지-남기기"><strong>Stash 메시지 남기기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash save &lt;<span class="s2">"stash 메시지"</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>
    <p>Stash 명령어를 실행할 때, 마치 commit 메시지와 같이 <span style="color: #8D4801"><strong>메시지를 작성</strong></span>할 수 있다. 이 명령어는 주로 각 stash를 구분하기 위해서 작성한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-save-message.webp" title="Stash list before git command stash save with message" alt="Stash list before git command stash save with message" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-save-message.webp" title="Git command to save working changes with message temporarily into stash stack" alt="Git command to save working changes with message temporarily into stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-save-message.webp" title="Stash list after git command stash save with message" alt="Stash list after git command stash save with message" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="특정-파일들을-선별하여-stash-실행하기"><strong>특정 파일들을 선별하여 stash 실행하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash <span class="nt">-k</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash <span class="nt">--keep-index</span>
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>Stage 영역의 파일들을 제외</strong></span>하고 stash를 생성하는 명령어이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-k.webp" title="Stash list before git command stash -k" alt="Stash list before git command stash -k" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-k.webp" title="Git command to save working changes except files in stage status temporarily into stash stack" alt="Git command to save working changes except files in stage status temporarily into stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-k.webp" title="Stash list after git command stash -k" alt="Stash list after git command stash -k" /></p>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash <span class="nt">-u</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash <span class="nt">--include-untracked</span>
</code></pre></div></div>
<ul>
  <li>
    <p>Stash 명령어는 기본적으로 추적 중인 파일들(Tracked status)만 stash를 생성한다. 그러나 이 옵션을 사용하면 <span style="color: #8D4801"><strong>추적 중이지 않은 파일들(Untracked status) 또한 함께 stash를 생성</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-u.webp" title="Stash list before git command stash -u" alt="Stash list before git command stash -u" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-u.webp" title="Git command to save working changes with untracked files temporarily into stash stack" alt="Git command to save working changes with untracked files temporarily into stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-u.webp" title="Stash list after git command stash -u" alt="Stash list after git command stash -u" /></p>
  </li>
</ul>

<hr />

<h4 id="stash-스택-확인하기"><span style="color: brown"><strong>Stash 스택 확인하기</strong></span></h4>
<h5 id="stash-목록-확인하기"><strong>Stash 목록 확인하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash list
</code></pre></div></div>
<ul>
  <li>Stash 스택에 존재하는 <span style="color: #8D4801"><strong>stash의 목록을 보여주는</strong></span> 명령어이다.</li>
  <li>각 stash의 이름은 “<span style="color: #8D4801"><strong>stash@{목록 번호}</strong></span>” 형태로 순서대로 부여된다. 목록 번호는 가장 최근에 저장된 stash인 Top 요소 stash부터 0으로 시작한다.</li>
  <li><span style="color: #8D4801"><strong>Stash 메시지를 따로 작성하지 않았을 경우</strong></span> HEAD가 가리키고 있는 <span style="color: #8D4801"><strong>commit 메시지를 출력</strong></span>한다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-list.webp" title="Git command to show list of stash" alt="Git command to show list of stash" /></li>
</ul>

<p><br /></p>

<h5 id="작업-영역과-stash-사이의-차이점-비교-명령어"><strong>작업 영역과 stash 사이의 차이점 비교 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash show
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>Stash 스택의 Top 요소 stash와 작업 영역을 비교</strong></span>하여 변경된 파일들의 상태를 <span style="color: #8D4801"><strong>간략하게 보여주는 명령어</strong></span>이다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-show.webp" title="Git command to show simple difference between top element stash and working changes" alt="Git command to show simple difference between top element stash and working changes" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash show <span class="nt">-p</span> stash@<span class="o">{</span>&lt;목록 번호&gt;<span class="o">}</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash show <span class="nt">--patch</span> stash@<span class="o">{</span>&lt;목록 번호&gt;<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>파일 및 commit 사이의 차이점을 비교하는 <span style="color: #8D4801"><strong>diff 명령어와 같이 지정한 stash와 작업 영역을 비교한 차이를 자세하게 보여주는 명령어</strong></span>이다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-show-p.webp" title="Git command to show detailed difference between the stash and working changes" alt="Git command to show detailed difference between the stash and working changes" /></li>
</ul>

<hr />

<h4 id="stash-스택에서-작업-꺼내기"><span style="color: brown"><strong>Stash 스택에서 작업 꺼내기</strong></span></h4>
<h5 id="저장된-작업-꺼내기"><strong>저장된 작업 꺼내기</strong></h5>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash-pop.webp" title="Diagram showing flow of git command stash pop" alt="Diagram showing flow of git command stash pop" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash pop
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>Top 요소 stash만 작업 영역으로 꺼내면서 stash 스택에서 삭제</strong></span>한다. Stash를 스택으로부터 꺼내올 때 현재 작업 영역에 이미 다른 변경 사항이 존재할 수 있기 때문에 <span style="color: #8D4801"><strong>자동으로 병합을 실행</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-pop.webp" title="Stash list before git command stash pop" alt="Stash list before git command stash pop" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-pop.webp" title="Git command to pop the top element stash from stash stack" alt="Git command to pop the top element stash from stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-pop.webp" title="Stash list after git command stash pop" alt="Stash list after git command stash pop" /></p>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash pop <span class="nt">--index</span>
</code></pre></div></div>
<ul>
  <li>
    <p>기본적으로 stash를 꺼내올 때 작업 변경 사항만 꺼내온다. 그러나 이 옵션을 사용할 경우 당시 <span style="color: #8D4801"><strong>스테이지 상태까지 그대로 꺼내올 수 있다.</strong></span></p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-pop-index.webp" title="Stash list before git command stash pop --index" alt="Stash list before git command stash pop --index" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-pop-index.webp" title="Git command to pop the top element stash even including stage status from stash stack" alt="Git command to pop the top element stash even including stage status from stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-pop-index.webp" title="Stash list after git command stash pop --index" alt="Stash list after git command stash pop --index" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="새로운-브랜치-생성하면서-저장된-작업-꺼내기"><strong>새로운 브랜치 생성하면서 저장된 작업 꺼내기</strong></h5>
<p>앞에서 얘기했듯이 현재 작업 영역에 stash를 꺼낼 때 다른 변경 사항이 이미 존재할 수 있고 이에 따라 <span style="color: #8D4801"><strong>자동으로 병합 중 conflict가 발생</strong></span>할 수 있는데 이런 경우 stash는 스택의 내용을 아직 삭제하지 않으며 수동으로 병합을 진행하거나 abort 하여 병합을 취소할 수 있다. 하지만 <span style="color: #8D4801"><strong>일반적으로 commit을 생성하지 않고 stash로 보관했다는 뜻은 아직 코드 작성이 완료되지 않았음을 의미</strong></span>하므로 당장 수동 병합을 진행하여 commit을 생성하는 것은 뭔가 석연치 않다. 다음의 명령어는 이런 상황에 권장하는 방법이다.</p>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash-branch.webp" title="Diagram showing flow of git command stash branch" alt="Diagram showing flow of git command stash branch" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash branch &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>지정된 브랜치 이름의 브랜치를 생성하고 HEAD를 이 브랜치로 이동시키며 Top 요소 stash 또는 지정된 stash를 작업 영역으로 꺼내면서 스택에서 삭제</strong></span>하는 명령어이다. 새로 브랜치를 생성하여 작업 사항들을 읽어오기 때문에 conflict가 발생할 일이 없다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-branch.webp" title="Stash list before git command stash branch" alt="Stash list before git command stash branch" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-branch.webp" title="Git command to create branch and switch to the branch then pop the stash" alt="Git command to create branch and switch to the branch then pop the stash" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-branch.webp" title="Stash list after git command stash branch" alt="Stash list after git command stash branch" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="저장된-작업-불러오기"><strong>저장된 작업 불러오기</strong></h5>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash-apply.webp" title="Diagram showing flow of git command stash apply" alt="Diagram showing flow of git command stash apply" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash apply
</code></pre></div></div>
<ul>
  <li>
    <p>Top 요소 stash를 작업 영역으로 읽어오는 것은 pop 명령어와 같지만 <span style="color: #8D4801"><strong>스택의 stash를 삭제하지 않는</strong></span> 명령어이다. 마치 stash를 복사하는 것처럼 동작한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-apply.webp" title="Stash list before git command stash apply" alt="Stash list before git command stash apply" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-apply.webp" title="Git command to copy the top element stash from stash stack" alt="Git command to copy the top element stash from stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-apply.webp" title="Stash list after git command stash apply" alt="Stash list after git command stash apply" /></p>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash apply stash@<span class="o">{</span>&lt;목록 번호&gt;<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>
    <p>Apply 명령어는 pop 명령어와 달리 <span style="color: #8D4801"><strong>스택의 중간에 존재하는 지정된 stash를 작업 영역으로 불러올 수 있다.</strong></span> 목록 번호를 작성하지 않을 경우 top 요소 stash를 불러온다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-apply-listnum.webp" title="Stash list before git command stash apply stash@{list number}" alt="Stash list before git command stash apply stash@{list number}" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-apply-listnum.webp" title="Git command to copy the stash having the list number from stash stack" alt="Git command to copy the stash having the list number from stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-apply-listnum.webp" title="Stash list after git command stash apply stash@{list number}" alt="Stash list after git command stash apply stash@{list number}" /></p>
  </li>
</ul>

<hr />

<h4 id="stash-삭제하기"><span style="color: brown"><strong>Stash 삭제하기</strong></span></h4>
<h5 id="stash-하나-삭제하기"><strong>Stash 하나 삭제하기</strong></h5>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash-drop.webp" title="Diagram showing flow of git command stash drop" alt="Diagram showing flow of git command stash drop" width="70%" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash drop
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>Top 요소 stash를 스택으로부터 삭제</strong></span>하는 명령어이다. <span style="color: #8D4801"><strong>Stash 스택은 임시 저장이 목적이므로 작업이 완료된 stash는 그때그때 정리하는 것이 좋다.</strong></span> (stash가 너무 많이 쌓이면 점점 어떤 stash가 언제의 이력인지 헷갈릴 수 있다.)</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-drop.webp" title="Stash list before git command stash drop" alt="Stash list before git command stash drop" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-drop.webp" title="Git command to drop a top element stash from stash stack" alt="Git command to drop a top element stash from stash stack" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/after-git-command-stash-drop.webp" title="Stash list after git command stash drop" alt="Stash list after git command stash drop" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="모든-stash-삭제하기"><strong>모든 stash 삭제하기</strong></h5>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-stash-clear.webp" title="Diagram showing flow of git command stash clear" alt="Diagram showing flow of git command stash clear" width="70%" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git stash clear
</code></pre></div></div>
<ul>
  <li>
    <p>Stash <span style="color: #8D4801"><strong>스택 안 모든 stash를 삭제</strong></span>하는 명령어이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/before-git-command-stash-clear.webp" title="Stash list before git command stash clear" alt="Stash list before git command stash clear" /></p>
  </li>
  <li>
    <p>명령어 실행 및 실행 후
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-stash-clear.webp" title="Git command to clear all stashes from stash stack" alt="Git command to clear all stashes from stash stack" /></p>
  </li>
</ul>

<hr />

<h4 id="작업-영역-정리하기"><span style="color: brown"><strong>작업 영역 정리하기</strong></span></h4>
<center><img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/diagram-git-command-clean.webp" title="Diagram showing flow of git command clean" alt="Diagram showing flow of git command clean" width="50%" /></center>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean
</code></pre></div></div>
<ul>
  <li>작업 영역에 <span style="color: #8D4801"><strong>추적 중이지 않은 모든 파일을 삭제하는 명령어</strong></span>이다. 특정 파일들을 모두 삭제하는 위험한 명령어이기 때문에 단독으로 실행할 경우 fatal error가 발생하며 <span style="color: #8D4801"><strong>옵션과 함께 실행</strong></span>해야 한다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean.webp" title="Git command to clean all untracked files from working directory" alt="Git command to clean all untracked files from working directory" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">-n</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">--dry-run</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>모의로 삭제를 실행</strong></span>하여 삭제될 파일을 사용자가 확인 할 수 있도록 출력해 준다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean-n.webp" title="Git command to do dry running to clean and then show the name of files will be cleaned" alt="Git command to do dry running to clean and then show the name of files will be cleaned" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">-f</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">--force</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>강제로 삭제를 실행</strong></span>하는 옵션이다. 현재 경로 내 파일만 삭제할 수 있다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean-f.webp" title="Git command to force to clean all untracked files from working directory" alt="Git command to force to clean all untracked files from working directory" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">-d</span>
</code></pre></div></div>
<ul>
  <li>기본적으로 파일만 삭제하는데 <span style="color: #8D4801"><strong>디렉토리까지 삭제</strong></span>하는 옵션이다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean-d.webp" title="Git command to clean all untracked files and directories from working directory" alt="Git command to clean all untracked files and directories from working directory" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">-x</span>
</code></pre></div></div>
<ul>
  <li>소문자 x 옵션은 <span style="color: #8D4801"><strong>.gitignore 파일에서 무시 중인 파일들 또한 삭제</strong></span>하는 옵션이다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean-x.webp" title="Git command to clean all untracked files and ignored files from working directory" alt="Git command to clean all untracked files and ignored files from working directory" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clean <span class="nt">-X</span>
</code></pre></div></div>
<ul>
  <li>대문자 X 옵션은 <span style="color: #8D4801"><strong>.gitignore 파일에서 무시 중인 파일들만 삭제</strong></span>하는 옵션이다.
<img src="/images/posts/2023-10-12-Temporary-saving-of-working-status-to-stack/git-command-clean-capital-x.webp" title="Git command to clean merely ignored files from working directory" alt="Git command to clean merely ignored files from working directory" /></li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 stash 스택을 이용하여 작업 변경 사항을 보관하고 다시 찾아도 보고 정리도 해보며 작업 영역의 관리 방법에 대하여 알아보았다. 이는 다수의 branch를 가진 프로젝트에서 협업할 때 자주 쓰일 수밖에 없는 명령어이므로 알아두면 좋다. 다음 포스트에서는 병합과 리베이스에 관하여 알아보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git stash" /><category term="git clean" /><summary type="html"><![CDATA[작업 영역의 변경 사항을 스택에 임시 저장하고 다시 불러와 보자. 그리고 작업 영역을 깔끔하게 정리 해보자.]]></summary></entry><entry><title type="html">8. Branch란 무엇일까?</title><link href="http://localhost:4000/github/2023/09/27/What-is-the-branch-on-Git/" rel="alternate" type="text/html" title="8. Branch란 무엇일까?" /><published>2023-09-27T19:33:29+09:00</published><updated>2023-09-27T19:33:29+09:00</updated><id>http://localhost:4000/github/2023/09/27/What-is-the-branch-on-Git</id><content type="html" xml:base="http://localhost:4000/github/2023/09/27/What-is-the-branch-on-Git/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#branch를-알아보자" title="Navigate to Let's learn what is the branch">Branch를 알아보자</a>
      <ul>
        <li><a href="#branch의-필요성" title="Navigate to Necessity of branch">Branch의 필요성</a></li>
        <li><a href="#branch의-종류" title="Navigate to Kind of branch">Branch의 종류</a></li>
      </ul>
    </li>
    <li><a href="#branch-관리하기" title="Navigate to Managing branch">Branch 관리하기</a>
      <ul>
        <li><a href="#branch-생성하기" title="Navigate to Creating branch">Branch 생성하기</a></li>
        <li><a href="#branch-명명-규칙" title="Navigate to Branch naming rule">Branch 명명 규칙</a></li>
        <li><a href="#upstream-연결" title="Navigate to Connecting upstream">Upstream 연결</a></li>
        <li><a href="#branch-삭제하기" title="Navigate to Deleting branch">Branch 삭제하기</a></li>
      </ul>
    </li>
    <li><a href="#branch-정보-확인하기" title="Navigate to Checking branch list">Branch 정보 확인하기</a>
      <ul>
        <li><a href="#브랜치-해시" title="Navigate to Branch hash">브랜치 해시</a></li>
        <li><a href="#로컬-브랜치-목록보기" title="Navigate to Checking list of local branch">로컬 브랜치 목록보기</a></li>
        <li><a href="#로컬-저장소의-추적-브랜치-목록보기" title="Navigate to Checking list of tracking branch">로컬 저장소의 추적 브랜치 목록보기</a></li>
        <li><a href="#원격-브랜치-목록보기" title="Navigate to Checking list of remote branch">원격 브랜치 목록보기</a></li>
        <li><a href="#모든-브랜치-목록보기" title="Navigate to Checking list of all branch">모든 브랜치 목록보기</a></li>
        <li><a href="#브랜치-병합-여부-확인하기" title="Navigate to Checking branches if merged">브랜치 병합 여부 확인하기</a></li>
      </ul>
    </li>
    <li><a href="#branch-간-이동하기" title="Navigate to Switching between branch">Branch 간 이동하기</a>
      <ul>
        <li><a href="#파일-체크아웃" title="Navigate to Checkout to file">파일 체크아웃</a></li>
        <li><a href="#이전-브랜치" title="Navigate to Last branch">이전 브랜치</a></li>
        <li><a href="#head-포인터" title="Navigate to HEAD pointer">HEAD 포인터</a></li>
        <li><a href="#브랜치-새로-생성하면서-이동하기" title="Navigate to Creating branch and Switching to the branch">브랜치 새로 생성하면서 이동하기</a></li>
        <li><a href="#커밋으로-이동하기" title="Navigate to Switching to commit">커밋으로 이동하기</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="들어가기-전에">들어가기 전에</h4>
<p>Branch는 Git에서 commit만큼이나 중요한 핵심 요소이다. commit이 Git의 내용물이라고 하면 branch는 일종의 포장과 같다고 볼 수 있는데 이 두 요소의 개념만 확실히 잡아둬도 Git의 원리를 좀 더 쉽게 이해할 수 있다.</p>

<center><img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/commits-and-branches.webp" title="Example image for several commits and branches" alt="Example image for several commits and branches" width="70%" /></center>

<p><br /></p>

<p><span style="color: #8D4801"><strong>Git 공부를 할 때 헷갈리는 것 중의 하나가 동일한 기능을 하는 여러 개의 다른 명령어</strong></span>라고 생각하는데 이번 포스트에서의 <span style="color: #8D4801"><strong>checkout</strong></span>과 <span style="color: #8D4801"><strong>switch</strong></span>가 그러하다. 과거엔 switch라는 명령어가 존재하지 않았고 checkout 명령어가 너무 여러 가지의 기능들을 모두 수행하고 있었는데, 그로 인해 Git에 새로 입문하는 사람들에게 어려움을 주었었다. “이 명령어는 이것도 하고 저것도 하는데 그래서 이건 대체 무슨 명령어인가?” 하는 모호성도 존재했고… 그래서 그런지 최근엔 restore, switch 등 명령어들이 하나하나의 세분된 명령어들로써 등장했고 그러다 보니 동일한 기능을 하는 명령어들이 많아진 것이다. (새로운 명령어를 추가했다 하더라도 과거의 명령어인 checkout을 여전히 사용 중인 사람들이 많기 때문에 당장 명령어의 기능을 수정하거나 삭제할 순 없다.) <span style="color: #8D4801"><strong>개인적인 생각으론 어느 한쪽을 골라야만 한다면 필자는 가장 최근에 추가된 명령어를 사용</strong></span>한다. 왜냐하면 동일한 기능을 함에도 새로 명령어를 추가했다는 것은 <span style="color: #8D4801"><strong>Git의 개발자들에게도 분명한 이유와 의도가 있기 때문</strong></span>이다.</p>

<hr />

<h4 id="branch를-알아보자"><span style="color: brown"><strong>Branch를 알아보자</strong></span></h4>
<p>Branch 단어는 나뭇가지, 지사, 분점, 둘 이상으로 나뉘다의 뜻이 있다. 단어의 뜻과 같이 <span style="color: #8D4801"><strong>Git의 branch 또한 저장공간을 나누는 데 실제 저장공간이 나누어지는 것은 아니며 가상의 저장공간이 생성</strong></span>되는 느낌이다.</p>

<center><img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/branch-in-naver-dictionary.jpg" title="Definition of branch in Naver dictionary" alt="Definition of branch in Naver dictionary" /></center>

<center>
  <a href="https://dict.naver.com/dict.search?query=branch&amp;from=tsearch" title="Navigate to Naver dictionary">
    <small><i class="fa fa-copyright" aria-hidden="true"></i>네이버 사전</small>
  </a>
</center>
<p><br /></p>

<h5 id="branch의-필요성"><strong>Branch의 필요성</strong></h5>
<center><img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/difference-while-working-in-file-system-between-no-version-management-and-Git.webp" title="Difference while working in file system between no version management and Git" alt="Difference while working in file system between no version management and Git" /></center>

<ul>
  <li>우리는 사실 이미 문서를 작성할 때 브랜치를 나눠서 진행하는 작업을 알게 모르게 해왔다. 수정해야 할 작업이 생겼을 때 원래의 프로젝트를 아무 조치 없이 그냥 수정했다간 실수를 복구하기가 너무 어렵기 때문에 원래의 프로젝트를 복사하여 백업해 두고 새로운 사본에 작업을 진행했었다. 하지만 이런 방식은 매번 수정할 때마다 사본이 통째로 생성되어 저장공간이 많이 낭비될 뿐만 아니라 향후 각각의 작업을 병합하는 것 또한 어려워진다. <span style="color: #8D4801"><strong>Git의 branch는 실질적인 working directory가 단 한 곳이며 공통 조상 커밋을 기준으로 변화된 커밋만 따로 저장하면 되므로 훨씬 더 효율적</strong></span>이다.</li>
</ul>

<p><br /></p>

<h5 id="branch의-종류"><strong>Branch의 종류</strong></h5>
<center><img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/image-that-showing-kind-of-branch.webp" title="Image that showing kind of branch" alt="Image that showing kind of branch" width="70%" /></center>

<ul>
  <li><strong>Default branch</strong>
    <ul>
      <li>당연하게도 Git에서 작업을 하려면 최소한 한 개 이상의 브랜치가 필요하다. 그러므로 <span style="color: #8D4801"><strong>Git은 저장소가 초기화될 때 무조건 Default branch를 한 개 생성</strong></span>한다.</li>
    </ul>
  </li>
  <li><span style="color: dodgerblue"><strong>Local branch</strong></span>
    <ul>
      <li>말 그대로 <span style="color: #8D4801"><strong>로컬 환경</strong></span>에서 작업할 때의 브랜치이다.</li>
    </ul>
  </li>
  <li><span style="color: red"><strong>Remote branch</strong></span>
    <ul>
      <li><span style="color: #8D4801"><strong>원격 저장소에 존재하는 브랜치</strong></span>를 Remote branch라고 한다. 내가 추적 브랜치를 통해 업로드한 원격 브랜치도 있지만 <span style="color: #8D4801"><strong>타 개발자 및 사용자가 해당 원격 저장소 안에 생성한 브랜치 또한 모두 포함하여 원격 브랜치</strong></span>라고 한다.</li>
      <li>원격 브랜치의 이름은 일반적으로 <span style="color: #8D4801"><strong>&lt;원격 저장소 이름/로컬 브랜치 이름&gt;</strong></span>의 형태를 보인다.</li>
      <li>원격 저장소와 연결된 로컬 저장소에서 새로운 브랜치를 생성하더라도 자동으로 원격 브랜치가 생성되지는 않는다. 또한, 원격 저장소에 새로운 브랜치가 등록되더라도 자동으로 로컬 브랜치가 생성되는 것은 아니다. 그러므로 <span style="color: #8D4801"><strong>별도의 명령어를 실행하여 저장소를 동기화</strong></span>해야 한다.</li>
    </ul>
  </li>
  <li><span style="color: darkorange"><strong>Tracking branch</strong></span>
    <ul>
      <li><span style="color: #8D4801"><strong>로컬 브랜치와 원격 브랜치를 중재하는 다리</strong></span> 역할을 하는 브랜치이다. 로컬 브랜치와 원격 브랜치와는 다르게 브랜치 간의 “관계”를 표현하는 브랜치라고 말할 수 있다.</li>
      <li>“git clone” 명령어로 원격 저장소를 복제할 때 저장소에 등록된 tracking branch들을 자동으로 함께 설정한다. (모든 브랜치 정보를 다 가져오진 않고 필요한 브랜치의 정보만 가져온다.)</li>
      <li><span style="color: limegreen"><strong>Upstream tracking</strong></span>
        <ul>
          <li><span style="color: #8D4801"><strong>Git에서 Upstream은 위(서버)로 흐르는 브랜치의 추적을 표현한 말</strong></span>이다. 로컬 저장소의 브랜치와 원격 저장소의 브랜치는 업로드할 수 있도록 연결되어 있다. 이러한 연결을 Upstream tracking이라고 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="branch-관리하기"><span style="color: brown"><strong>Branch 관리하기</strong></span></h4>
<h5 id="branch-생성하기"><strong>Branch 생성하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch &lt;브랜치 이름&gt; <span class="o">(</span>커밋 해시값<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>새 브랜치를 생성하면 처음에는 <span style="color: #8D4801"><strong>브랜치 포인터</strong></span>만 있는 브랜치가 생성된다.</li>
  <li>
    <p>브랜치를 생성할 때 일반적으로 마지막 commit을 가리키고 있는 HEAD를 기준으로 생성된다. 그러나 <span style="color: #8D4801"><strong>직접 커밋 해시값을 입력할 경우 해당 commit을 기준으로 브랜치가 생성</strong></span>된다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-branch-name.webp" title="Branch list before git command branch &lt;new branch name&gt;" alt="Branch list before git command branch &lt;new branch name&gt;" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-name.webp" title="Git command to create new branch" alt="Git command to create new branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-branch-name.webp" title="Branch list after git command branch &lt;new branch name&gt;" alt="Branch list after git command branch &lt;new branch name&gt;" /></li>
</ul>

<p><br /></p>

<h5 id="branch-명명-규칙"><strong>Branch 명명 규칙</strong></h5>
<ul>
  <li>브랜치 이름은 알파벳과 숫자, 밑줄(_), 하이픈(-)으로 시작할 수 있다.</li>
  <li>브랜치 이름에는 빈칸이나 공백 문자, 대부분의 특수문자를 사용할 수 없다.</li>
  <li>아스키 제어 문자는 포함할 수 없고 유니코드 문자는 포함할 수 있다.</li>
  <li>Git은 브랜치 이름의 대소문자를 구별하여 다른 문자로 취급한다.</li>
  <li>일부 Git 호스팅 서비스 및 운영 체제에는 브랜치 이름의 길이 제한이 있을 수 있다. 일반적으로 최대 255자 이내로 작성하는 것이 좋다.</li>
  <li>브랜치 이름은 중복해서 사용하지 않아야 한다.</li>
</ul>

<p><br /></p>

<h5 id="upstream-연결"><strong>Upstream 연결</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-u</span> &lt;원격 저장소 이름/브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--set-upstream-to</span> &lt;원격 저장소 이름/브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>기존에 <span style="color: #8D4801"><strong>로컬에 존재하는 브랜치를 해당 원격 브랜치로 업스트림 연결</strong></span>할 수 있다.</li>
  <li><span style="color: #8D4801"><strong>연결하고자 하는 로컬 브랜치로 이동 후</strong></span> 명령어를 실행하여야 한다.</li>
  <li>
    <p>해당 원격 브랜치가 <span style="color: #8D4801"><strong>원격 저장소에 존재하지 않을 경우</strong></span> 명령어를 실행할 수 없다. 원격 저장소에 해당 원격 브랜치가 존재함에도 명령어 실행이 안 될 경우 “git fetch 원격 저장소 이름” 명령어를 통해서 원격 저장소 정보를 가져와야 한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-branch-u.webp" title="Branch list before git command branch -u" alt="Branch list before git command branch -u" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-u.webp" title="Git command to make upstream tracking for exist local and remote branches" alt="Git command to make upstream tracking for exist local and remote branches" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-branch-u.webp" title="Branch list after git command branch -u" alt="Branch list after git command branch -u" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-t</span> &lt;원격 저장소 이름/브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">--track</span> &lt;원격 저장소 이름/브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>해당 브랜치 이름의 로컬 브랜치를 생성하며 이동하고 해당 원격 브랜치로 업스트림 연결</strong></span>까지 한다.</li>
  <li><span style="color: #8D4801"><strong>해당 브랜치 이름의 로컬 브랜치가 존재하지 않을 경우</strong></span>에만 실행할 수 있다.</li>
  <li>
    <p>해당 원격 브랜치가 <span style="color: #8D4801"><strong>원격 저장소에 존재하지 않을 경우</strong></span> 명령어를 실행할 수 없다. 원격 저장소에 해당 원격 브랜치가 존재함에도 명령어 실행이 안 될 경우 “git fetch 원격 저장소 이름” 명령어를 통해서 원격 저장소 정보를 가져와야 한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-checkout-t.webp" title="Branch list before git command checkout -t" alt="Branch list before git command checkout -t" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-checkout-t.webp" title="Git command to make new local branch and upstream tracking moreover checkout to the new local branch" alt="Git command to make new local branch and upstream tracking moreover checkout to the new local branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-checkout-t.webp" title="Branch list after git command checkout -t" alt="Branch list after git command checkout -t" /></li>
</ul>

<p><br /></p>

<h5 id="branch-삭제하기"><strong>Branch 삭제하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-d</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--delete</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>브랜치의 <span style="color: #8D4801"><strong>일반적인 삭제 방법</strong></span>이다. Working directory에 작업한 기록이 없고 Stage area가 깨끗하게 비어 있을 때만 명령어가 실행된다. 또한 병합되지 않은 commit이 존재할 경우 브랜치를 삭제할 수 없다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-branch-d.webp" title="Branch list before git command branch -d" alt="Branch list before git command branch -d" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-d.webp" title="Git command to delete the branch" alt="Git command to delete the branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-branch-d.webp" title="Branch list after git command branch -d" alt="Branch list after git command branch -d" /></p>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-D</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>병합되지 않은 commit이 존재하는 브랜치를 <span style="color: #8D4801"><strong>강제로 삭제</strong></span>할 수 있다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-branch-capital-letter-d.webp" title="Branch list before git command branch -D" alt="Branch list before git command branch -D" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-capital-letter-d.webp" title="Git command to force to delete the branch" alt="Git command to force to delete the branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-branch-capital-letter-d.webp" title="Branch list after git command branch -D" alt="Branch list after git command branch -D" /></p>
  </li>
</ul>

<hr />

<h4 id="branch-정보-확인하기"><span style="color: brown"><strong>Branch 정보 확인하기</strong></span></h4>
<h5 id="브랜치-해시"><strong>브랜치 해시</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rev-parse &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>해당 <span style="color: #8D4801"><strong>브랜치 포인터가 가리키는 커밋 해시값을 확인</strong></span>할 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-rev-parse.webp" title="Git command to show commit hash value for the branch pointer" alt="Git command to show commit hash value for the branch pointer" /></li>
</ul>

<p><br /></p>

<h5 id="로컬-브랜치-목록보기"><strong>로컬 브랜치 목록보기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch
</code></pre></div></div>
<ul>
  <li>모든 <span style="color: #8D4801"><strong>로컬 브랜치를 목록</strong></span>으로 볼 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch.webp" title="Git command to show list of local branch" alt="Git command to show list of local branch" /></li>
</ul>

<p><br /></p>

<h5 id="로컬-저장소의-추적-브랜치-목록보기"><strong>로컬 저장소의 추적 브랜치 목록보기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-vv</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>로컬 저장소의 모든 추적 브랜치를 목록</strong></span>으로 볼 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-vv.webp" title="Git command to show list of tracking branch in local repository" alt="Git command to show list of tracking branch in local repository" /></li>
</ul>

<p><br /></p>

<h5 id="원격-브랜치-목록보기"><strong>원격 브랜치 목록보기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-r</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--remotes</span>
</code></pre></div></div>
<ul>
  <li>모든 <span style="color: #8D4801"><strong>원격 브랜치를 목록</strong></span>으로 볼 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-r.webp" title="Git command to show list of remote branch" alt="Git command to show list of remote branch" /></li>
</ul>

<p><br /></p>

<h5 id="모든-브랜치-목록보기"><strong>모든 브랜치 목록보기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-a</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--all</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>모든 브랜치를 목록</strong></span>으로 볼 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-a.webp" title="Git command to show list of all branch" alt="Git command to show list of all branch" /></li>
</ul>

<p><br /></p>

<h5 id="브랜치-병합-여부-확인하기"><strong>브랜치 병합 여부 확인하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--merged</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>병합한 브랜치</strong></span>를 목록으로 볼 수 있다. 병합한 브랜치는 <span style="color: #8D4801"><strong>애스터리스크(*) 기호</strong></span>로 표시된다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-merged.webp" title="Git command to show list of merged local branch" alt="Git command to show list of merged local branch" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">--no-merged</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>병합하지 않은 브랜치</strong></span>를 목록으로 볼 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-branch-no-merged.webp" title="Git command to show list of unmerged local branch" alt="Git command to show list of unmerged local branch" /></li>
</ul>

<hr />

<h4 id="branch-간-이동하기"><span style="color: brown"><strong>Branch 간 이동하기</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch &lt;브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>현재 브랜치를 떠나 해당 브랜치로 이동하는 명령어이다. 브랜치를 이동한다는 의미는 <span style="color: #8D4801"><strong>HEAD 포인터가 해당 브랜치를 가리키는 것</strong></span>이다.</li>
  <li>Working directory에 작업한 기록이 없고 Stage area가 깨끗하게 비어 있을 때만 이동할 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-switch.webp" title="Git command to switch to the branch" alt="Git command to switch to the branch" /></li>
</ul>

<p><br /></p>

<h5 id="파일-체크아웃"><strong>파일 체크아웃</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">--</span> &lt;파일 이름&gt;
</code></pre></div></div>
<ul>
  <li>브랜치뿐만 아니라 <span style="color: #8D4801"><strong>파일로도 checkout</strong></span> 할 수 있다.</li>
  <li>Working directory에 작업한 기록이 존재하고 Stage area에 commit 되지 않은 기록이 존재할 경우, 마치 마지막 commit 기준으로 <span style="color: #8D4801"><strong>파일을 복원하는 것과 같이 동작</strong></span>한다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-checkout-file.webp" title="Git command to checkout to the file" alt="Git command to checkout to the file" /></li>
</ul>

<p><br /></p>

<h5 id="이전-브랜치"><strong>이전 브랜치</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch -
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout -
</code></pre></div></div>
<ul>
  <li>리눅스에서 대시(-) 기호는 이전 디렉토리를 의미한다. 이 명령어는 <span style="color: #8D4801"><strong>이전 브랜치로의 이동</strong></span>을 뜻한다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-switch--.webp" title="Git command to switch to last branch" alt="Git command to switch to last branch" /></li>
</ul>

<p><br /></p>

<h5 id="head-포인터"><strong>HEAD 포인터</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch <span class="nt">--detach</span> HEAD^^^
git switch <span class="nt">--detach</span> HEAD~~~
git switch <span class="nt">--detach</span> HEAD~3
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout HEAD^^^
git checkout HEAD~~~
git checkout HEAD~3
</code></pre></div></div>
<ul>
  <li>
    <p>HEAD 포인터를 기준으로 상대적 위치 이동 명령어이다. <span style="color: #8D4801"><strong>캐럿(^) 또는 물결(~) 기호</strong></span>를 사용하여 commit의 상대적 위치를 지정할 수 있다. <span style="color: #8D4801"><strong>기호의 숫자만큼 이전 commit으로 이동</strong></span>한다. <span style="color: #8D4801"><strong>물결(~) 기호를 이용할 경우 기호 1개와 원하는 이동량만큼의 숫자 입력만으로</strong></span> 이동할 수 있다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-switch-detach-head.webp" title="Git command to switch back for number of steps from HEAD pointer" alt="Git command to switch back for number of steps from HEAD pointer" /></p>
  </li>
  <li><span style="color: #8D4801"><strong>BEHIND</strong></span>
    <ul>
      <li><span style="color: #8D4801">로컬 저장소로 내려받지 않은 commit이 존재하는 상태</span>이다.</li>
      <li>보통 다른 개발자가 코드를 수정하고 먼저 commit 하여 원격 저장소의 commit이 자신의 로컬 저장소보다 더 최신 상태인 것을 뜻한다.</li>
    </ul>
  </li>
  <li><span style="color: #8D4801"><strong>AHEAD</strong></span>
    <ul>
      <li><span style="color: #8D4801">서버로 전송되지 않은 로컬 commit이 존재하는 상태</span>이다.</li>
      <li>보통 업로드되어 있는 서버의 commit 개수보다 로컬 저장소의 HEAD 포인터를 기준으로 로컬 브랜치에 존재하는 commit의 개수가 많은 상태를 뜻한다.
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/branches-in-remote-repository-in-github.webp" title="Branches in remote repository in Github" alt="Branches in remote repository in Github" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="브랜치-새로-생성하면서-이동하기"><strong>브랜치 새로 생성하면서 이동하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch <span class="nt">-c</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch <span class="nt">--create</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> &lt;브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>&lt;브랜치 이름&gt; 뒤에 <span style="color: #8D4801"><strong>&lt;원격 저장소 이름/브랜치 이름&gt;</strong></span> 를 추가할 경우 <span style="color: #8D4801"><strong>업스트림 설정까지 동시에 진행</strong></span>할 수 있다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/before-git-command-switch-c.webp" title="Branch list before git switch -c" alt="Branch list before git switch -c" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-switch-c.webp" title="Git command to create new branch and to switch to the branch" alt="Git command to create new branch and to switch to the branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/after-git-command-switch-c.webp" title="Branch list after git switch -c" alt="Branch list after git switch -c" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="커밋으로-이동하기"><strong>커밋으로 이동하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch <span class="nt">--detach</span> &lt;커밋 해시값&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;커밋 해시값&gt;
</code></pre></div></div>
<p><img src="/images/posts/2023-09-27-What-is-the-branch-on-Git/git-command-switch-detach-commit-hash-value.webp" title="Git command to switch to the commit" alt="Git command to switch to the commit" /></p>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 Git의 핵심 요소 중 하나인 브랜치에 관하여 알아보았다. 이제 Git의 커다란 청사진은 그려졌고 앞으로는 이 commit과 branch를 응용한 여러 가지 작업을 알아볼 시간만 남았다. 다음 포스트에서는 Working directory에 작업 중이던 내용을 임시 저장할 수 있는 스태시 기능을 알아보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git branch" /><category term="git rev-parse" /><category term="git checkout" /><category term="git switch" /><summary type="html"><![CDATA[Git의 branch가 무엇인지 알아보자. 그리고 branch를 관리하는 명령어들이 무엇이 있는지 알아보고 branch 간 이동하며 작업을 해보자.]]></summary></entry><entry><title type="html">7. 원격 저장소와 Commit 주고받기</title><link href="http://localhost:4000/github/2023/09/20/Transfering-commit-with-remote-repository/" rel="alternate" type="text/html" title="7. 원격 저장소와 Commit 주고받기" /><published>2023-09-20T08:31:44+09:00</published><updated>2023-09-20T08:31:44+09:00</updated><id>http://localhost:4000/github/2023/09/20/Transfering-commit-with-remote-repository</id><content type="html" xml:base="http://localhost:4000/github/2023/09/20/Transfering-commit-with-remote-repository/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#원격-저장소-생성하기" title="Navigate to Creating remote repository">원격 저장소 생성하기</a>
      <ul>
        <li><a href="#내-컴퓨터에-원격-저장소를-생성해-보자" title="Navigate to Let's make remote repository to own computer">내 컴퓨터에 원격 저장소를 생성해 보자</a></li>
        <li><a href="#github-회원가입" title="Navigate to Signing up to Github">Github 회원가입</a></li>
        <li><a href="#personal-access-tokens" title="Navigate to Personal access tokens">Personal access tokens</a></li>
        <li><a href="#github-서버에-원격-저장소를-생성해-보자" title="Navigate to Let's make remote repository to server in Github">Github 서버에 원격 저장소를 생성해 보자</a></li>
      </ul>
    </li>
    <li><a href="#원격-저장소-관리하기" title="Navigate to Managing remote repository">원격 저장소 관리하기</a>
      <ul>
        <li><a href="#원격-저장소-목록" title="Navigate to List of remote repository">원격 저장소 목록</a></li>
        <li><a href="#로컬-저장소와-원격-저장소-연결" title="Navigate to Connecting local and remote repository">로컬 저장소와 원격 저장소 연결</a></li>
        <li><a href="#원격-저장소-이름-변경" title="Navigate to Renaming remote repository">원격 저장소 이름 변경</a></li>
        <li><a href="#원격-저장소-자세한-정보-출력" title="Navigate to Displaying detail of remote repository">원격 저장소 자세한 정보 출력</a></li>
        <li><a href="#원격-저장소와의-연결-삭제" title="Navigate to Removing connection with remote repository">원격 저장소와의 연결 삭제</a></li>
        <li><a href="#원격-저장소와-추적-브랜치-동기화" title="Navigate to Removing unexist tracking branch in remote repository">원격 저장소와 추적 브랜치 동기화</a></li>
      </ul>
    </li>
    <li><a href="#원격-저장소와-작업하기" title="Navigate to Working with remote repository">원격 저장소와 작업하기</a>
      <ul>
        <li><a href="#원격-저장소에-전송하기" title="Navigate to Uploading commit to remote repository">원격 저장소에 전송하기</a></li>
        <li><a href="#원격-저장소에서-내려받기" title="Navigate to Fetching commit from remote repository and merging commit with tracking branch">원격 저장소에서 내려받기</a></li>
        <li><a href="#원격-저장소에서-일단-가져오기" title="Navigate to Fetching commit from remote repository">원격 저장소에서 일단 가져오기</a></li>
        <li><a href="#가져온-데이터-수동으로-병합하기" title="Navigate to Merging commit with tracking branch">가져온 데이터 수동으로 병합하기</a></li>
      </ul>
    </li>
    <li><a href="#협업할-때-작업-순서" title="Navigate to The sequence to work when cooperating">협업할 때 작업 순서</a></li>
  </ol>
</blockquote>

<hr />

<h4 id="들어가기-전에">들어가기 전에</h4>
<p>원격 저장소와 commit을 주고받으려면 일단 원격 저장소가 존재해야 한다. 먼저, 원격 저장소를 생성해 보자. 원격 저장소는 당장 내 컴퓨터 경로 내에 생성할 수도 있고 Github와 같은 Git 호스팅 서버를 이용할 수도 있다.</p>

<hr />

<h4 id="원격-저장소-생성하기"><span style="color: brown"><strong>원격 저장소 생성하기</strong></span></h4>
<h5 id="내-컴퓨터에-원격-저장소를-생성해-보자"><strong>내 컴퓨터에 원격 저장소를 생성해 보자</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote add &lt;원격 저장소 이름&gt; &lt;디렉토리 경로&gt;
</code></pre></div></div>
<ul>
  <li>내 컴퓨터 내에 디렉토리 경로에 원격 저장소를 생성하는 명령어이다. 내 컴퓨터를 NFS(Network File System) 등의 서버로 이용할 때 사용할 수 있다. 그러나, <span style="color: #8D4801"><strong>모든 데이터가 내 컴퓨터에 집중되어 있기 때문에 그에 따르는 위험 또한 존재</strong></span>하므로 주의하여 사용하여야 한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-add-local-path.webp" title="Git command to create remote repository to directory path" alt="Git command to create remote repository to directory path" /></li>
</ul>

<p><br /></p>

<h5 id="github-회원가입"><strong>Github 회원가입</strong></h5>
<ol>
  <li>
    <p>이제 서버에 내 원격 저장소를 생성하기 위해 대표적인 Git 호스팅 플랫폼인 Github에 회원가입을 해보자. 이메일을 입력하고 Sign up 버튼을 클릭하면 바로 다음 페이지로 진행된다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/signing-up-to-github-official-website-1.webp" title="Home page of Github official website" alt="Home page of Github official website" /></p>
  </li>
  <li>
    <p>사용할 비밀번호와 닉네임을 입력하고 Continue 버튼을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/signing-up-to-github-official-website-2.webp" title="Sign up page to fill essential informations of Github official website" alt="Sign up page to fill essential informations of Github official website" /></p>
  </li>
  <li>
    <p>확인 버튼을 클릭하면 나오는 간단한 퀴즈를 풀어서 매크로가 아님을 증명한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/signing-up-to-github-official-website-3.webp" title="Checking if it is a person while signing up" alt="Checking if it is a person while signing up" /></p>
  </li>
  <li>
    <p>입력한 이메일을 확인하여 도착해있는 이메일 코드를 입력하면 회원가입이 완료된다. 
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/signing-up-to-github-official-website-4.webp" title="Page to fill email code in order to qualify signing up" alt="Page to fill email code in order to qualify signing up" /></p>
  </li>
</ol>

<p><br /></p>

<h5 id="personal-access-tokens"><strong>Personal access tokens</strong></h5>
<p><span style="color: #8D4801"><strong>Github의 API를 사용하여 원격 저장소에 명령어를 사용하여 작업을 수행하려면 이 Personal access token이 필요</strong></span>하다. 터미널 환경에서 인증 화면이 표시되었을 때 아이디와 비밀번호가 아닌 이 token을 입력해야 권한이 생긴다. 그럼, 이제 Personal access token을 만들어보자.</p>

<ol>
  <li>
    <p>먼저 처음 Github에 로그인했을 때 나타나는 홈 화면 우측 상단의 프로필사진을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-1.webp" title="Home page when login status to Github" alt="Home page when login status to Github" /></p>
  </li>
  <li>
    <p>팝업되는 메뉴에서 Settings 메뉴를 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-2.webp" title="Popup menu when profile picture clicked in Github" alt="Popup menu when profile picture clicked in Github" width="30%" /></p>
  </li>
  <li>
    <p>Settings 페이지에서 좌측 가장 하단의 Developer settings 버튼을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-3.webp" title="Menu in settings page in Github" alt="Menu in settings page in Github" width="30%" /></p>
  </li>
  <li>
    <p>사진의 순서대로 버튼을 클릭하여 새로운 token 생성을 진행한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-4.webp" title="Developer settings page in Github" alt="Developer settings page in Github" /></p>
  </li>
  <li>
    <p>팝업되는 메뉴에서 하단의 classic token을 선택한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-5.webp" title="Popup menu when generate new token clicked" alt="Popup menu when generate new token clicked" /></p>
  </li>
  <li>
    <ul>
      <li>생성하고자 하는 token의 이름을 목적에 따라 입력한다.</li>
      <li>token의 유효기간을 설정한다. (보안을 위해서는 주기적으로 바꿔주는 게 좋을 수 있으나… 필자는 무기한으로 사용하고 있다.)</li>
      <li>다음으로 아래에 옵션이 많지만, 초심자의 경우엔 일단 repository에만 접근할 수 있어도 된다. (추후 token 적용 범위 수정도 가능하다.)
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-6.webp" title="Page to fill information about new personal access token" alt="Page to fill information about new personal access token" /></li>
    </ul>
  </li>
  <li>
    <p>token 생성 버튼을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-7.webp" title="Generate token button" alt="Generate token button" /></p>
  </li>
  <li>token 생성이 완료되었다. <span style="color: #8D4801"><strong>token의 코드는 지금 단 한 번만 보여주므로 반드시 안전한 곳에 기록해 둬야 한다.</strong></span> (터미널 환경에서 인증할 때 사용될 수 있다.)
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/setting-personal-access-token-8.webp" title="Page when completed generating new token" alt="Page when completed generating new token" /></li>
</ol>

<p><br /></p>

<h5 id="github-서버에-원격-저장소를-생성해-보자"><strong>Github 서버에 원격 저장소를 생성해 보자</strong></h5>
<ol>
  <li>
    <p>자 이제 회원가입도 완료되었고 원격 저장소를 생성해 보자. 먼저 처음 Github에 로그인했을 때 나타나는 홈 화면 우측 상단의 프로필사진을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/creating-remote-repository-1.webp" title="Home page when login status to Github" alt="Home page when login status to Github" /></p>
  </li>
  <li>
    <p>팝업되는 메뉴에서 Your repositories 메뉴를 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/creating-remote-repository-2.webp" title="Popup menu when profile picture clicked in Github" alt="Popup menu when profile picture clicked in Github" width="30%" /></p>
  </li>
  <li>
    <p>우측 상단의 새 원격 저장소 생성 버튼을 클릭한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/creating-remote-repository-3.webp" title="Personal repositories page in Github" alt="Personal repositories page in Github" /></p>
  </li>
  <li>
    <ul>
      <li>원하는 원격 저장소의 이름을 입력한다.</li>
      <li>Private 저장소는 유료 결제를 해야만 선택할 수 있다. 선택되어 있는 Public을 그대로 두면 된다.</li>
      <li>README file이란 이 저장소의 프로젝트를 소개할 수 있는 markdown 문서이다. 필요하다면 생성한다.</li>
      <li><a href="/github/2023/09/11/Working-in-Git-repository/#추적하고-싶지-않은-파일-목록" title="Navigate to gitignore file">이전 포스트</a>에서 생성해 보았던 .gitignore 파일을 여기서 생성할 수 있다. <span style="color: #8D4801"><strong>선택하는 언어에 따라 default로 설정되어 있는 값들이 존재해서 편리</strong></span>하다. 무엇을 추적에서 제외해야할지 애매하다면 여기서 파일을 생성하자.</li>
      <li>프로젝트에 적용될 라이센스 종류에 따라 파일을 추가할 수 있다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/creating-remote-repository-4.webp" title="Page to fill information about new remote repository" alt="Page to fill information about new remote repository" /></li>
    </ul>
  </li>
  <li>새 원격 저장소 생성이 완료되었다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/creating-remote-repository-5.webp" title="New remote repository page" alt="New remote repository page" /></li>
</ol>

<hr />

<h4 id="원격-저장소-관리하기"><span style="color: brown"><strong>원격 저장소 관리하기</strong></span></h4>
<h5 id="원격-저장소-목록"><strong>원격 저장소 목록</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote
</code></pre></div></div>
<ul>
  <li>원격 저장소의 <span style="color: #8D4801"><strong>이름을 목록으로 출력</strong></span>한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote.webp" title="Git command to display list of name for remote repositorie" alt="Git command to display list of name for remote repositorie" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote <span class="nt">-v</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote <span class="nt">--verbose</span>
</code></pre></div></div>
<ul>
  <li>원격 저장소의 <span style="color: #8D4801"><strong>이름과 URL을 목록으로 출력</strong></span>한다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-v.webp" title="Git command to display list of name and URL for remote repositorie" alt="Git command to display list of name and URL for remote repositorie" /></li>
</ul>

<p><br /></p>

<h5 id="로컬-저장소와-원격-저장소-연결"><strong>로컬 저장소와 원격 저장소 연결</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote add &lt;원격 저장소 이름&gt; &lt;원격 저장소 URL&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>Github 서버의 원격 저장소를 연결</strong></span>하는 명령어이다. 서버의 데이터와 로컬의 데이터로 나뉘어져서 관리되므로 내 컴퓨터에 원격 저장소를 생성하는 것보다 상대적으로 안전하며 저장소가 서버에 존재하기 때문에 다른 개발자들과의 소통 또는 협업이 가능하다.
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-add.webp" title="Git command to add remote repository from server in Github" alt="Git command to add remote repository from server in Github" /></li>
</ul>

<p><br /></p>

<h5 id="원격-저장소-이름-변경"><strong>원격 저장소 이름 변경</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote rename &lt;변경 전 원래 이름&gt; &lt;변경할 이름&gt;
</code></pre></div></div>
<p><img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-rename.webp" title="Git command to rename remote repository" alt="Git command to rename remote repository" /></p>

<p><br /></p>

<h5 id="원격-저장소-자세한-정보-출력"><strong>원격 저장소 자세한 정보 출력</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote show &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<p><img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-show.webp" title="Git command to display details about the remote repository" alt="Git command to display details about the remote repository" /></p>

<p><br /></p>

<h5 id="원격-저장소와의-연결-삭제"><strong>원격 저장소와의 연결 삭제</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote <span class="nb">rm</span> &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<p><img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-remote-rm.webp" title="Git command to remove remote repository from local" alt="Git command to remove remote repository from local" /></p>

<p><br /></p>

<h5 id="원격-저장소와-추적-브랜치-동기화"><strong>원격 저장소와 추적 브랜치 동기화</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote prune &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>로컬 저장소와 원격 저장소의 추적 브랜치를 확인하고 <span style="color: #8D4801"><strong>원격 저장소에 더 이상 존재하지 않는 추적 브랜치를 로컬 저장소에서 제거</strong></span>한다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/all-branches-list-before-remote-prune.webp" title="Git all branches list before git command remote prune" alt="Git all branches list before git command remote prune" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-remote-prune.webp" title="Git command to remove branch that currently doesn't exist in remote repository" alt="Git command to remove branch that currently doesn't exist in remote repository" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/all-branches-list-after-remote-prune.webp" title="Git all branches list after git command remote prune" alt="Git all branches list after git command remote prune" /></p>
  </li>
</ul>

<hr />

<h4 id="원격-저장소와-작업하기"><span style="color: brown"><strong>원격 저장소와 작업하기</strong></span></h4>
<p><img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/how-to-transfer-commit-between-local-repository-and-remote-repository.webp" title="Flow chart of data between local repository and remote repository" alt="Flow chart of data between local repository and remote repository" /></p>
<ul>
  <li>원격 저장소와 작업 시 데이터의 흐름도를 그려봤다. <span style="color: dodgerblue"><strong>Local branch</strong></span>와 <span style="color: darkorange"><strong>tracking branch</strong></span>는 이해를 도우려고 따로 작성했지만, 실제 존재하는 위치는 <span style="color: green"><strong>local repository</strong></span> 안에 저장되어 있어서 <strong>점선</strong>으로 표시했다.</li>
</ul>

<p><br /></p>

<h5 id="원격-저장소에-전송하기"><strong>원격 저장소에 전송하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>로컬 브랜치의 데이터를 <span style="color: #8D4801"><strong>원격 저장소로 전송</strong></span>하는 명령어이다.</li>
  <li>“로컬 브랜치 이름” 대신 <span style="color: #8D4801"><strong>“태그 이름”을 사용할 경우 태그 정보를 전송</strong></span>할 수 있다.</li>
  <li><strong>이름이 다른 태그</strong>
    <ul>
      <li><span style="color: #8D4801"><strong>“태그 이름:원격 저장소에서 사용할 태그 이름” 형태</strong></span>로 이름을 작성하면 로컬 태그를 다른 이름으로 원격 저장소에 전송할 수 있다.</li>
      <li>
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push &lt;원격 저장소 이름&gt; &lt;태그 이름:원격 저장소에서 사용할 태그 이름&gt;
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><span style="color: #8D4801"><strong>다른 개발자들과 협업 중일 경우 영향을 줄 수 있으므로 신중하게 사용해야 한다.</strong></span></p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-push.webp" title="Remote repository in Github before git command push" alt="Remote repository in Github before git command push" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-push.webp" title="Git command to transfer datas to remote repository from local repository" alt="Git command to transfer datas to remote repository from local repository" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-push.webp" title="Remote repository in Github after git command push" alt="Remote repository in Github after git command push" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-d</span> &lt;원격 저장소 이름&gt; &lt;레퍼런스 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">--delete</span> &lt;원격 저장소 이름&gt; &lt;레퍼런스 이름&gt;
</code></pre></div></div>
<ul>
  <li>더 이상 필요하지 않은 레퍼런스(브랜치, 태그 등)를 원격 저장소에서 삭제하는 옵션이다.</li>
  <li>
    <p><span style="color: #8D4801"><strong>원격 저장소에서 해당 레퍼런스(브랜치, 태그 등)를 다시 복구할 수 없으므로 신중하게 사용해야 한다.</strong></span></p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-push-d.webp" title="Remote repository in Github before git command push -d" alt="Remote repository in Github before git command push -d" width="30%" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-push-d.webp" title="Git command to remove unnecessary references in remote repository" alt="Git command to remove unnecessary references in remote repository" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-push-d.webp" title="Remote repository in Github after git command push -d" alt="Remote repository in Github after git command push -d" width="30%" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">--tags</span> &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>로컬 저장소에 있는 <span style="color: #8D4801"><strong>모든 태그</strong></span>를 원격 저장소로 전송하는 옵션이다. 기본적으로 옵션 없는 “git push” 명령어로는 태그를 원격 저장소로 전송하지 않는다. 그러므로 태그를 전송해야 할 때 이 옵션을 사용할 수 있다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-push-tags.webp" title="Remote repository in Github before git command push --tags" alt="Remote repository in Github before git command push --tags" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-push-tags.webp" title="Git command to transfer tags to remote repository from local repository" alt="Git command to transfer tags to remote repository from local repository" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-push-tags.webp" title="Remote repository in Github after git command push --tags" alt="Remote repository in Github after git command push --tags" /></p>
  </li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-f</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">--force</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>강제로 전송을 실행하는 옵션이다.</li>
  <li>
    <p>이미 push한 적이 있는 commit을 amend 했거나 rebase, cherry-pick 등의 명령어 사용으로 <span style="color: #8D4801"><strong>기존 commit의 해시값이 변경되었을 경우</strong></span> 이 옵션을 통해 push 해야하는데 이런 경우엔 <span style="color: #8D4801"><strong>매우 주의해야 한다.</strong></span></p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-push-f.webp" title="Remote repository in Github before git command push -f" alt="Remote repository in Github before git command push -f" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-push-f.webp" title="Git command to force to transfer datas to remote repository from local repository" alt="Git command to force to transfer datas to remote repository from local repository" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-push-f.webp" title="Remote repository in Github after git command push -f" alt="Remote repository in Github after git command push -f" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-u</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">--set-upstream</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>로컬 브랜치의 데이터를 원격 저장소로 전송하면서, <span style="color: #8D4801"><strong>해당 로컬 브랜치의 추적 브랜치를 설정하는 옵션이다.</strong></span> “git branch” 명령어와 다르게 해당 원격 브랜치가 존재하지 않더라도 생성하면서 연결한다.</li>
  <li><strong>이름이 다른 브랜치</strong>
    <ul>
      <li>일반적으로 로컬 저장소의 브랜치와 원격 저장소의 브랜치 이름은 동일하게 사용한다.</li>
      <li>하지만 동일한 이름을 사용하기 어려운 상황이 존재한다. 원격 저장소에는 타 개발자 또한 접근할 수 있기 때문에 만약 타 개발자가 나와 동일한 브랜치 이름을 사용하고 업로드한 경우 내 브랜치를 전송할 때 충돌이 생긴다.</li>
      <li><span style="color: #8D4801"><strong>“로컬 브랜치 이름” 대신에 “로컬 브랜치 이름:원격 저장소에서 사용할 로컬 브랜치의 이름” 형태</strong></span>로 이름을 작성하면 서로 다른 이름의 로컬 브랜치와 원격 브랜치를 수동으로 연결할 수 있다. 즉, 원격 저장소에서만 사용될 새로운 이름을 로컬 브랜치에게 부여할 수 있다.</li>
      <li>
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-u</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름:원격 저장소에서 사용할 로컬 브랜치의 이름&gt;
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-push-u.webp" title="Remote repository in Github before git command push -u" alt="Remote repository in Github before git command push -u" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-push-u.webp" title="Git command to set tracking branch for the local branch as well as to transfer datas to remote repository from local repository" alt="Git command to set tracking branch for the local branch as well as to transfer datas to remote repository from local repository" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-push-u.webp" title="Remote repository in Github after git command push -u" alt="Remote repository in Github after git command push -u" /></li>
</ul>

<p><br /></p>

<h5 id="원격-저장소에서-내려받기"><strong>원격 저장소에서 내려받기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>원격 저장소의 데이터를 로컬 브랜치로 내려받는 명령어이다.</li>
  <li><span style="color: #8D4801"><strong>fetch 명령어와 merge 명령어의 혼용과 동일한 동작을 한다. merge 동작이 포함되어 있기 때문에 conflict가 발생할 수 있다.</strong></span></li>
  <li>
    <p><span style="color: #8D4801"><strong>commit하지 않은 수정사항이 working directory에 존재할 경우 명령어가 실행되지 않으므로 해당 내용을 commit 하거나 stash로 임시 저장한 후에 pull 명령어를 실행해야 한다.</strong></span></p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-pull.webp" title="Log result before git command pull" alt="Log result before git command pull" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-pull.webp" title="Git command to fetch datas and merge with local branch" alt="Git command to fetch datas and merge with local branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-pull.webp" title="Log result after git command pull" alt="Log result after git command pull" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull <span class="nt">--allow-unrelated-histories</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>관계 없는 commit 이력의 병합을 허용하는 옵션이다. 관계없다는 의미는 병합하려는 두 개의 이력이 공통 조상 commit을 갖고 있지 않음을 뜻한다.</strong></span></li>
  <li>
    <p>보통 처음 로컬 저장소를 “git init” 명령어를 통해 생성하고 Github에 새 원격 저장소를 생성한 후 연결하여 처음 내려받으려 시도할 경우 이 옵션을 사용해야 내려받을 수 있다. 새로 생성된 두 저장소가 공통된 base를 갖고 있을 리 없기 때문이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-pull-allow-unrelated-histories.webp" title="Log result before git command pull --allow-unrelated-histories" alt="Log result before git command pull --allow-unrelated-histories" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-pull-allow-unrelated-histories.webp" title="Git command to fetch datas which are unrelated with local history and merge with local branch" alt="Git command to fetch datas which are unrelated with local history and merge with local branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-pull-allow-unrelated-histories.webp" title="Log result after git command pull --allow-unrelated-histories" alt="Log result after git command pull --allow-unrelated-histories" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull <span class="nt">-f</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull <span class="nt">--force</span> &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>원격 저장소의 데이터로 로컬 브랜치를 강제로 덮어쓰는 옵션</strong></span>이다. 덮어쓴다고 하지만 원격 저장소에 존재하지 않는 로컬 브랜치의 파일들이 삭제되거나 하진 않는다. 다만, 로컬 브랜치와 원격 저장소 양쪽에 존재하는 파일의 경우 원격 저장소의 최신 commit으로 로컬 브랜치의 파일들이 덮어씌워진다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-pull-f.webp" title="Log result before git command pull -f" alt="Log result before git command pull -f" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-pull-f.webp" title="Git command to force both actions fetching datas and merging with local branch" alt="Git command to force both actions fetching datas and merging with local branch" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-pull-f.webp" title="Log result after git command pull -f" alt="Log result after git command pull -f" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="원격-저장소에서-일단-가져오기"><strong>원격 저장소에서 일단 가져오기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch &lt;원격 저장소 이름&gt; &lt;로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>원격 저장소의 데이터를 추적 브랜치로 가져오는 명령어</strong></span>이다.</li>
  <li>“로컬 브랜치 이름”을 입력하지 않을 경우 <span style="color: #8D4801"><strong>원격 저장소의 모든 브랜치 정보</strong></span>를 가져올 수 있다. 다수의 개발자와 협업할 경우 먼저 fetch를 한 후 차례차례 브랜치를 병합한 후에 작업을 진행해야 한다.</li>
  <li>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch &lt;원격 저장소 이름&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-fetch.webp" title="Log result before git command fetch" alt="Log result before git command fetch" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-fetch.webp" title="Git command to bring datas to tracking branch" alt="Git command to bring datas to tracking branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-fetch.webp" title="Log result after git command fetch" alt="Log result after git command fetch" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch <span class="nt">-p</span> &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch <span class="nt">--prune</span> &lt;원격 저장소 이름&gt;
</code></pre></div></div>
<ul>
  <li>
    <p>원격 저장소의 모든 브랜치 정보를 가져오면서 <span style="color: #8D4801"><strong>원격 저장소에 더 이상 존재하지 않는 추적 브랜치를 로컬 저장소에서 제거</strong></span>하는 옵션이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-fetch-p.webp" title="Git all branches list before git command fetch -p" alt="Git all branches list before git command fetch -p" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-fetch-p.webp" title="Git command to remove tracking branches which doesn't exist for now and bring all branch datas" alt="Git command to remove tracking branches which doesn't exist for now and bring all branch datas" /></p>
  </li>
  <li>
    <p>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-fetch-p.webp" title="Git all branches list after git command fetch -p" alt="Git all branches list after git command fetch -p" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="가져온-데이터-수동으로-병합하기"><strong>가져온 데이터 수동으로 병합하기</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git merge &lt;원격 저장소 이름/로컬 브랜치 이름&gt;
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>추적 브랜치의 데이터를 로컬 브랜치와 병합하는 명령어</strong></span>이다.</li>
  <li>
    <p>merge 명령어의 여러 가지 자세한 사용법은 추후 포스트로 따로 다룰 예정이다.</p>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/before-git-command-merge.webp" title="Log result before git command merge" alt="Log result before git command merge" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/git-command-merge.webp" title="Git command to merge datas between tracking branch and local branch" alt="Git command to merge datas between tracking branch and local branch" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/after-git-command-merge.webp" title="Log result after git command merge" alt="Log result after git command merge" /></li>
</ul>

<hr />

<h4 id="협업할-때-작업-순서"><span style="color: brown"><strong>협업할 때 작업 순서</strong></span></h4>
<p><img src="/images/posts/2023-09-20-Transfering-commit-with-remote-repository/the-sequence-to-cooperate-to-work-in-one-branch.webp" title="The sequence to cooperate to work in one branch" alt="The sequence to cooperate to work in one branch" /></p>
<ul>
  <li>실제 협업에서는 각자 브랜치를 생성해서 따로 작업하고 pull request를 통해 병합할 가능성이 높으나 만약 하나의 브랜치에 여러 명이 작업할 경우를 가정해 보자.</li>
  <li>기본적으로 원격 저장소에는 다수의 개발자가 동시에 commit을 push 할 수 없다. 그러므로, 여러 명이 협력하여 개발할 때는 순차적으로 push를 진행해야 한다. 또한 <span style="color: #8D4801"><strong>원격 저장소에 push 하기 위해서는 로컬 저장소를 최신 상태로 유지해야 한다.</strong></span> 만약 commit이 순차적이지 않을 경우에 Git은 push 명령어 실행을 거부한다. 로컬 저장소가 최신 상태에서만 push를 허용하는 것은 충돌을 최소화하기 위해서이다.</li>
  <li>최대한 충돌을 피하는 방법은 로컬과 원격 저장소를 빈번하게 최신으로 유지해 주는 것이다. 포인트는 <span style="color: #8D4801"><strong>Working directory에서 작업을 시작하기 전에 무조건 pull 명령어를 실행</strong></span>하고 작업내역을 <span style="color: #8D4801"><strong>commit한 이후엔 또 다시 pull 명령어를 실행</strong></span>한 후에 push 명령어를 실행하는 것이다.</li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pull ⇒ write code ⇒ add ⇒ commit ⇒ pull ⇒ push
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 “나”만이 존재하는 로컬 환경을 벗어나 다른 개발자들과 협업이 가능한 원격 저장소를 생성하고 원격 저장소와 작업시 필수적인 명령어도 알아보았다. 첫 포스트부터 오늘까지 알아본 명령어들만 사용할 줄 알아도 이제 본인의 개발 이력 정도는 스스로 관리할 수 있을 정도의 수준이 되었다. 하지만 완벽하게 모든 버전관리 issue를 해결하기엔 아직 모자란다. 오늘 내용 중에서도 추적 브랜치, 태그 등 아직 모르는 내용들이 있을 수 있다. 천천히 전부 알아갈 예정이므로 초조할 필요 없다. 다음 포스트에서는 commit 못지않게 중요한 개념인 branch에 대해서 심층 탐구를 해보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="personal access tokens" /><category term="git remote" /><category term="git push" /><category term="git pull" /><category term="git fetch" /><summary type="html"><![CDATA[Github에 접속하여 원격 저장소를 생성해 보자. 기록해 둔 commit을 원격 저장소로 전송하고 다시 로컬 저장소에 내려받아 보자.]]></summary></entry><entry><title type="html">6. Commit이란 무엇일까?</title><link href="http://localhost:4000/github/2023/09/13/What-is-the-commit-on-Git/" rel="alternate" type="text/html" title="6. Commit이란 무엇일까?" /><published>2023-09-13T12:29:51+09:00</published><updated>2023-09-13T12:29:51+09:00</updated><id>http://localhost:4000/github/2023/09/13/What-is-the-commit-on-Git</id><content type="html" xml:base="http://localhost:4000/github/2023/09/13/What-is-the-commit-on-Git/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#commit이란-무엇일까" title="Navigate to What is commit?">Commit이란 무엇일까?</a>
      <ul>
        <li><a href="#head란-무엇일까" title="Navigate to What is HEAD?">HEAD란 무엇일까?</a></li>
        <li><a href="#snapshot-기반-접근-방식" title="Navigate to Snapshot based approach">Snapshot 기반 접근 방식</a></li>
      </ul>
    </li>
    <li><a href="#commit-해보기" title="Navigate to Let's commit">Commit 해보기</a>
      <ul>
        <li><a href="#commit-메시지" title="Navigate to Commit message">Commit 메시지</a></li>
        <li><a href="#-만약-실습-도중-실수할-상황에-대비하여-몇-가지-복귀-명령어들을-미리-알아보자" title="Navigate to Command to restore commit for Git">Commit 복귀 명령어</a></li>
        <li><a href="#파일-추적과-커밋을-동시에-실행하는-옵션" title="Navigate to Option to execute both add all files and commit">파일 추적과 커밋을 동시에 실행하는 옵션</a></li>
        <li><a href="#에디터를-사용하지-않는-간이-commit-메시지-작성-옵션" title="Navigate to Option to commit without editor">에디터를 사용하지 않는 간이 commit 메시지 작성 옵션</a></li>
        <li><a href="#가장-짧게-작성할-수-있는-commit-옵션" title="Navigate to Option to write the shortest commit">가장 짧게 작성할 수 있는 commit 옵션</a></li>
        <li><a href="#빈-메시지의-commit-옵션" title="Navigate to Option to commit with empty message">빈 메시지의 commit 옵션</a></li>
        <li><a href="#commit-메시지-수정" title="Navigate to Commit message amend">Commit 메시지 수정</a></li>
        <li><a href="#commit-메시지를-작성할-때-파일-간-또는-커밋-간-차이-참조-옵션" title="Navigate to Option to refer diff when writing commit message">Commit 메시지를 작성할 때 파일 간 또는 커밋 간 차이 참조 옵션</a></li>
      </ul>
    </li>
    <li><a href="#commit을-확인해-보자" title="Navigate to Why don't we check the commit logs">Commit을 확인해 보자</a>
      <ul>
        <li><a href="#commit-id" title="Navigate to Commit ID">Commit ID</a></li>
        <li><a href="#log에-출력할-commit의-개수를-설정하는-옵션" title="Navigate to Option to set number of commit to show">Log에 출력할 commit의 개수를 설정하는 옵션</a></li>
        <li><a href="#log에-commit의-내용을-짧게-표시하는-옵션" title="Navigate to Option to show short log">Log에 commit의 내용을 짧게 표시하는 옵션</a></li>
        <li><a href="#간략한-commit-해시값과-메시지만-출력하는-옵션-prettyshort-옵션보다-더-짧음" title="Navigate to Option to show oneline log">간략한 commit 해시값과 메시지만 출력하는 옵션</a></li>
        <li><a href="#log에-각-commit의-diff를-포함하는-옵션" title="Navigate to Option to show log with diff">Log에 각 commit의 diff를 포함하는 옵션</a></li>
        <li><a href="#log에-각-commit의-히스토리를-포함하는-옵션" title="Navigate to Option to show log with history">Log에 각 commit의 히스토리를 포함하는 옵션</a></li>
        <li><a href="#log에-브랜치의-흐름-그래프를-포함하는-옵션" title="Navigate to Option to show log with graph">Log에 브랜치의 흐름 그래프를 포함하는 옵션</a></li>
        <li><a href="#log에-가장-짧은-commit-정보와-그래프를-출력하는-옵션" title="Navigate to Mixed option to show the shortest log with graph">Log에 가장 짧은 commit 정보와 그래프를 출력하는 옵션</a></li>
        <li><a href="#특정-commit의-상세-정보-확인-명령어" title="Navigate to Command to show detail log">특정 commit의 상세 정보 확인 명령어</a></li>
        <li><a href="#파일-및-commit-사이의-차이점-비교-명령어" title="Navigate to Command to show diff">파일 및 commit 사이의 차이점 비교 명령어</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="들어가기-전에">들어가기 전에</h4>
<p>필자는 Github를 포도 농장에 비유하곤 한다. 그러면 각 사용자의 로컬 저장소를 하나의 포도나무라고 보고 Branch는 포도송이, Commit은 포도알이라고 생각하면 무언가 딱 맞다는 느낌이 들었었다. 코드를 포도라고 생각하면 코딩이 좀 더 맛있게 느껴질지도…? 각설하고 본론으로 들어가보자…</p>

<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/compare-github-to-grape.webp" title="Compare github to grape" alt="Compare github to grape" /></p>

<hr />

<h4 id="commit이란-무엇일까"><span style="color: brown"><strong>Commit이란 무엇일까?</strong></span></h4>
<p>들어 본 적은 있는 단어였으나 어떤 의미로 Git에서 사용되는지는 몰랐었다. 그래서 사전을 한번 찾아보았는데 가장 가까운 의미는 “~을 적어 두다”로 보인다. 즉, Git에서 commit이란 당시 <span style="color: #8D4801"><strong>Stage 영역의 파일 내용들을 적어 두는 행위</strong></span>를 뜻한다.</p>
<div class="image-slider-static">
  <img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/commit-in-naver-dictionary.jpg" title="Definition of commit in Naver dictionary" alt="Definition of commit in Naver dictionary" />
</div>

<center>
  <a href="https://en.dict.naver.com/#/entry/enko/4dd1c73ab1734e23861c8dacd2b2bc72" title="Navigate to Naver dictionary">
    <small><i class="fa fa-copyright" aria-hidden="true"></i>네이버 사전</small>
  </a>
</center>
<p><br /></p>

<h5 id="head란-무엇일까"><strong>HEAD란 무엇일까?</strong></h5>
<ul>
  <li>HEAD는 한마디로 <span style="color: #8D4801"><strong>commit을 가리키고 있는 참조 포인터</strong></span>이다. 포인터 하면 생각나는 게 c언어인 것 같다. 대학생 시절 처음엔 비교적 재밌게 프로그래밍 수업을 듣던 학생들도 포인터 개념에서 많이 포기를 하고 전과를 하거나 코딩 자체에 관심을 잃고 졸업 후 다른 방향의 직업을 생각나게 하는 악명높은 문법이었다. 아무튼 본론으로 돌아와서… 포인터의 문어적 의미 그대로 “무언가를 가리키고 있다.”라고 생각하면 되는데 Git에서는 그 가리키고 있는 것이 commit이라고 생각하면 된다.</li>
  <li>아래의 예시에서 볼 수 있듯이 <span style="color: #8D4801"><strong>HEAD는 기본적으로 마지막 commit 위치 (commit이 변화한 최종 위치)</strong></span>를 가리키고 있다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/example-of-head.jpg" title="HEAD in git log" alt="HEAD in git log" /></li>
  <li>아직 commit이 없는 경우엔 HEAD 또한 존재하지 않는다. 최소한 <span style="color: #8D4801"><strong>한 번 이상 commit을 실행해야 HEAD가 생성</strong></span>된다. HEAD가 가리키고 있는 commit의 hash 값은 다음과 같은 경로에 해당 브랜치명으로 저장이 된다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/location-of-head-information-in-git-directory.jpg" title="Location of the information which commit HEAD is pointing" alt="Location of the information which commit HEAD is pointing" /></li>
</ul>

<p><br /></p>

<h5 id="snapshot-기반-접근-방식"><strong>Snapshot 기반 접근 방식</strong></h5>
<ul>
  <li>Git의 각 커밋에는 커밋이 이루어진 당시 전체 프로젝트의 snapshot에 대한 참조가 포함되어 있다. commit을 실행하면 <span style="color: #8D4801"><strong>HEAD가 가리키고 있는 commit의 snapshot과 현재 Stage area를 비교하여 새로운 commit을 생성</strong></span>한다.</li>
  <li>Git은 이 Snapshot 기반 접근 방식을 사용하기 때문에 <span style="color: #8D4801"><strong>전체 파일의 여러 복사본을 저장하는 대신 스냅샷 간의 차이점만 저장하면 되므로 변경 사항과 기록을 효율적으로 관리</strong></span>할 수 있다. (빠른 속도, 적은 용량 사용)
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/principle-of-git-commit-snapshot.webp" title="The principle of git commit snapshot" alt="The principle of git commit snapshot" /></li>
</ul>

<hr />

<h4 id="commit-해보기"><span style="color: brown"><strong>Commit 해보기</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit
</code></pre></div></div>
<ul>
  <li>commit 명령어를 실행하면 위에서 알아봤듯이 HEAD commit의 snapshot과 Stage area를 비교하여 <span style="color: #8D4801"><strong>새로운 commit 객체를 생성</strong></span>한다. 그리고 <span style="color: #8D4801"><strong>commit이 완료되면 Stage area는 비워진다.</strong></span></li>
  <li>실제로 실행해 보면 <span style="color: #8D4801"><strong>바로 commit이 완료되는 것이 아니라 vim 에디터(또는 core.editor로 설정한 다른 에디터)가 출력</strong></span>되는 것을 확인할 수 있다. commit 메시지를 작성해야 하기 때문이다. 아래에서 간단한 사용법을 알아보자. (<a href="/github/2023/08/26/Getting-Started-with-Git/#git의-코어-에디터-설정" title="Navigate to Setting environment for Git">Git 환경설정 中 core 에디터</a>)
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit.jpg" title="Git command to commit" alt="Git command to commit" /></li>
</ul>

<p><br /></p>

<h5 id="commit-메시지"><strong>Commit 메시지</strong></h5>
<ul>
  <li>각각의 commit에 대한 정보를 입력할 수 있다.</li>
  <li>만약 commit.template을 작성해 뒀다면 vim 화면에 함께 출력된다. (<a href="/github/2023/08/26/Getting-Started-with-Git/#commit-템플릿-설정" title="Navigate to Setting environment for Git">Git 환경설정 中 commit 템플릿</a>)</li>
  <li><span style="color: indianred"><strong>Git은 기본적으로 commit 명령어를 실행할 때 반드시 commit 메시지를 작성해야 한다.</strong></span></li>
  <li>
    <table>
      <thead>
        <tr>
          <th style="text-align: center">간단한 vim 에디터 사용법</th>
          <th style="text-align: center">명령어</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">내용 편집</td>
          <td style="text-align: center"><strong>ESC -&gt; :i</strong></td>
        </tr>
        <tr>
          <td style="text-align: center">저장</td>
          <td style="text-align: center"><strong>ESC -&gt; :w</strong></td>
        </tr>
        <tr>
          <td style="text-align: center">에디터 종료</td>
          <td style="text-align: center"><strong>ESC -&gt; :q</strong></td>
        </tr>
        <tr>
          <td style="text-align: center">저장 후 에디터 종료</td>
          <td style="text-align: center"><strong>ESC -&gt; :wq</strong></td>
        </tr>
        <tr>
          <td style="text-align: center">느낌표는 강제로 실행을 뜻한다</td>
          <td style="text-align: center"><strong>ESC -&gt; :q!</strong></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/editing-commit-message-by-vim-editor.jpg" title="Editing commit message by vim editor" alt="Editing commit message by vim editor" /></li>
</ul>

<p><br /></p>

<h6 id="-만약-실습-도중-실수할-상황에-대비하여-몇-가지-복귀-명령어들을-미리-알아보자"><span style="color: indianred"><strong>※ 만약 실습 도중 실수할 상황에 대비하여 몇 가지 복귀 명령어들을 미리 알아보자.</strong></span></h6>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">--</span> &lt;파일명&gt;
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git restore &lt;파일명&gt;
</code></pre></div></div>
<ul>
  <li>잘못 수정한 파일을 바로 이전 커밋으로 즉, 수정 전 상태로 되돌리는 명령어들이다. checkout 명령어는 restore 명령어가 존재하기 전 과거에 사용하던 방법으로 되도록 <span style="color: #8D4801"><strong>restore 명령어 사용을 추천</strong></span>한다. (checkout 명령어는 다른 용도와 목적으로 사용된다.)
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-restore.jpg" title="Git command to restore the file" alt="Git command to restore the file" /></li>
</ul>

<p><br /></p>

<h5 id="파일-추적과-커밋을-동시에-실행하는-옵션"><strong>파일 추적과 커밋을 동시에 실행하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">-a</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--all</span>
</code></pre></div></div>
<ul>
  <li>
    <p>“git add .; git commit” 명령어와 동일한 동작을 한다. commit 작성을 좀 더 편리하게 만들어주는 명령어이지만 <span style="color: #8D4801"><strong>자동으로 모든 수정 사항을 추적</strong></span>하기 때문에 만약에 <span style="color: #8D4801"><strong>당장 commit을 원치 않았던 수정 사항들이 존재한다면 문제가 발생하므로 유의하여 사용</strong></span>해야 한다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-a.jpg" title="Git command to commit with option automatically adding all files before committing" alt="Git command to commit with option automatically adding all files before committing" /></p>
  </li>
  <li>
    <p>이 명령어는 <span style="color: #8D4801"><strong>이미 tracked 상태인 파일에만 사용</strong></span>할 수 있다. 즉, Untracked 상태의 파일이 존재할 경우 명령어 실행에 실패한다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-a-when-it-is-failed.jpg" title="Git command to commit with option automatically adding all files before committing when it is failed" alt="Git command to commit with option automatically adding all files before committing when it is failed" /></p>
  </li>
</ul>

<p><br /></p>

<h5 id="에디터를-사용하지-않는-간이-commit-메시지-작성-옵션"><strong>에디터를 사용하지 않는 간이 commit 메시지 작성 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">-m</span> &lt;<span class="s2">"commit 메시지"</span><span class="o">&gt;</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--message</span> &lt;<span class="s2">"commit 메시지"</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>commit 메시지를 작성 후 명령어 실행 시 에디터가 실행되지 않고 바로 commit이 진행된다. <span style="color: #8D4801"><strong>필자의 경우 매우 자주 사용하는 commit 방법이다. 혼자서 개발하는 작은 프로젝트의 경우 대부분의 commit을 이 옵션으로 작성하게 되는 것 같다.</strong></span>
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-m.jpg" title="Git command to commit without displaying editor" alt="Git command to commit without displaying editor" /></li>
</ul>

<p><br /></p>

<h5 id="가장-짧게-작성할-수-있는-commit-옵션"><strong>가장 짧게 작성할 수 있는 commit 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">-am</span> &lt;<span class="s2">"commit 메시지"</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>자동으로 파일을 추적하고 commit을 실행하는데 에디터가 실행되지 않고 작성한 commit 메시지로 바로 commit이 진행된다. 여러 작업을 한 번에 묶어서 처리하기 때문에 아마 <span style="color: #8D4801"><strong>가장 짧게 commit을 작성하는 방법</strong></span>일 것이다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-am.jpg" title="Git command to commit with both options those a and m" alt="Git command to commit with both options those a and m" /></li>
</ul>

<p><br /></p>

<h5 id="빈-메시지의-commit-옵션"><strong>빈 메시지의 commit 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--allow-empty-message</span> <span class="nt">-m</span> <span class="s2">""</span>
</code></pre></div></div>
<ul>
  <li>가능하면 추천하고 싶진 않은 방법이다. 만약 필요하다면 commit 메시지가 없는 <span style="color: #8D4801"><strong>빈 메시지의 커밋을 생성</strong></span>하는 방법도 있다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-allow-empty-message-m.jpg" title="Git command to commit with option that allowing empty message" alt="Git command to commit with option that allowing empty message" /></li>
</ul>

<p><br /></p>

<h5 id="commit-메시지-수정"><strong>Commit 메시지 수정</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--amend</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>마지막 commit에 대한 수정 명령어</strong></span>로써 메시지 수정뿐만 아니라 해당 commit에 새롭게 추가하고 싶은 파일 또한 추가할 수 있다. 마지막 commit이 아닌 commit을 수정하고 싶다면 rebase 등 복잡한 과정을 거쳐야 한다.</li>
  <li>
    <p><span style="color: indianred"><strong>주의해야 할 점은 기존 commit의 해시 코드가 바뀐다</strong></span>는 것이다. 해시 코드는 commit의 ID라고 생각하면 되는데 아래에서 알아볼 예정이다.</p>

    <ul>
      <li>만약 수정 전의 commit을, push를 통해 이미 원격 저장소에 전송한 상태라면 정상적인 방법으로는 원격 저장소에 다시 전송할 수가 없다. (<span style="color: indianred"><strong>git push -f를 통해 강제로 전송</strong></span>해야 한다.)</li>
    </ul>
  </li>
  <li>
    <p>명령어 실행 전
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-log-before-amended.jpg" title="Git log before the last commit amended" alt="Git log before the last commit amended" /></p>
  </li>
  <li>
    <p>명령어 실행
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-amend.jpg" title="Git command to amend the last commit" alt="Git command to amend the last commit" /></p>
  </li>
  <li>명령어 실행 후
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-log-after-amended.jpg" title="Git log after the last commit amended" alt="Git log after the last commit amended" /></li>
</ul>

<p><br /></p>

<h5 id="commit-메시지를-작성할-때-파일-간-또는-커밋-간-차이-참조-옵션"><strong>Commit 메시지를 작성할 때 파일 간 또는 커밋 간 차이 참조 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">-v</span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit <span class="nt">--verbose</span>
</code></pre></div></div>
<ul>
  <li>사실 “git log -p” 명령어를 이용하면 어떤 commit이든지 diff를 확인할 수 있다. 다만, “git commit”과 “git commit -v”의 차이점은 <span style="color: #8D4801"><strong>에디터에서 commit 메시지를 작성할 때 diff 내용을 눈으로 확인할 수 있게 디스플레이해주는 것</strong></span> 뿐이다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-commit-v.jpg" title="Git command to commit with option that showing diff between files or commits into vim editor" alt="Git command to commit with option that showing diff between files or commits into vim editor" /></li>
</ul>

<hr />

<h4 id="commit을-확인해-보자"><span style="color: brown"><strong>Commit을 확인해 보자</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log
</code></pre></div></div>
<ul>
  <li>
    <p><span style="color: #8D4801"><strong>“git status” 명령어와 마찬가지로 매우 자주 쓰이는 명령어</strong></span>이다. Commit 기록의 목록을 최신 commit 기록부터 내림차순으로 출력한다. 또한 여러 가지 옵션을 활용하여 다양한 형태로 로그를 확인할 수 있다. 아래에서 확인해 보자.</p>

    <ul>
      <li>Git은 분산형 버전관리 도구이므로 개인의 컴퓨터에 설정한 시간 정보를 바탕으로 commit 기록을 작성한다. <span style="color: #8D4801"><strong>작업 중인 컴퓨터가 다른 국가 및 지역의 시간이거나 잘못된 시간으로 설정되어 있을 경우도 있으므로 commit 기록의 시간은 무조건 신용할 수는 없다.</strong></span>
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log.jpg" title="Git command to show log for commits" alt="Git command to show log for commits" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="commit-id"><strong>Commit ID</strong></h5>
<ul>
  <li>문어적 표현 그대로 <span style="color: #8D4801"><strong>특정 commit을 가리키는 Identifier(고유 식별자)</strong></span>이다. 이 ID를 기준으로 각 커밋을 구별하고 버전관리에 필요한 동작을 수행할 수 있다.</li>
  <li><span style="color: #8D4801"><strong>Git의 commit ID는 SHA-1(Secure Hash Algorithm-1)이라는 해시 알고리즘을 채택</strong></span>하고 있다. 과거에는 안전함을 슬로건으로 내걸었으나 현재는 안전하진 않고 단지 레거시 코드들과의 호환성을 위해 채택하고 있다고 전해진다. 이 알고리즘은 데이터를 고정된 크기의 해시값으로 변환하는 알고리즘으로 40자리의 hexa 값으로 이루어진 중복되지 않는 commit ID를 생성한다.</li>
  <li>버전관리를 위해 commit ID를 사용할 때 40자리의 16진수는 정말 큰 숫자이므로 앞자리 문자들이 바뀔 경우는 거의 없으므로 <span style="color: #8D4801"><strong>편의상 앞에서 7자리~10자리까지의 문자만 사용</strong></span>하더라도 충분히 중복되지 않게 사용할 수 있다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-commit-id.jpg" title="Git log to check commit IDs" alt="Git log to check commit IDs" /></li>
</ul>

<p><br /></p>

<h5 id="log에-출력할-commit의-개수를-설정하는-옵션"><strong>Log에 출력할 commit의 개수를 설정하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log -&lt;출력할 commit의 개수&gt;
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-number.jpg" title="Git command to show log of commits within numbers" alt="Git command to show log of commits within numbers" /></p>

<p><br /></p>

<h5 id="log에-commit의-내용을-짧게-표시하는-옵션"><strong>Log에 commit의 내용을 짧게 표시하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span>short
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-pretty-short.jpg" title="Git command to show log with pretty short information" alt="Git command to show log with pretty short information" /></p>

<p><br /></p>

<h5 id="간략한-commit-해시값과-메시지만-출력하는-옵션-prettyshort-옵션보다-더-짧음"><strong>간략한 commit 해시값과 메시지만 출력하는 옵션 (–pretty=short 옵션보다 더 짧음)</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--oneline</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-oneline.jpg" title="Git command to show log with one line information" alt="Git command to show log with one line information" /></p>

<p><br /></p>

<h5 id="log에-각-commit의-diff를-포함하는-옵션"><strong>Log에 각 commit의 diff를 포함하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--p</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-p.jpg" title="Git command to show log with difference between commits" alt="Git command to show log with difference between commits" /></p>

<p><br /></p>

<h5 id="log에-각-commit의-히스토리를-포함하는-옵션"><strong>Log에 각 commit의 히스토리를 포함하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--stat</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-stat.jpg" title="Git command to show log with history of commit" alt="Git command to show log with history of commit" /></p>

<p><br /></p>

<h5 id="log에-브랜치의-흐름-그래프를-포함하는-옵션"><strong>Log에 브랜치의 흐름 그래프를 포함하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--graph</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-graph.jpg" title="Git command to show log with graph about branches flow" alt="Git command to show log with graph about branches flow" /></p>

<p><br /></p>

<h5 id="log에-가장-짧은-commit-정보와-그래프를-출력하는-옵션"><strong>Log에 가장 짧은 commit 정보와 그래프를 출력하는 옵션</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--graph</span> <span class="nt">--pretty</span><span class="o">=</span>oneline <span class="nt">--abbrev-commit</span>
</code></pre></div></div>
<p><img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-log-graph-pretty-oneline-abbrev-commit.jpg" title="Git command to show log as one line information with graph about branches flow" alt="Git command to show log as one line information with graph about branches flow" /></p>

<p><br /></p>

<h5 id="특정-commit의-상세-정보-확인-명령어"><strong>특정 commit의 상세 정보 확인 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git show &lt;commit ID&gt;
</code></pre></div></div>
<ul>
  <li>사실상 “git log” 명령어와 동일한 기능을 하는 명령어이다. 실제로 –help 옵션으로 확인해 봐도 두 명령어가 함께 묶여서 표시된다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-show.jpg" title="Git command to show the log" alt="Git command to show the log" /></li>
</ul>

<p><br /></p>

<h5 id="파일-및-commit-사이의-차이점-비교-명령어"><strong>파일 및 commit 사이의 차이점 비교 명령어</strong></h5>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git diff &lt;object&gt;
</code></pre></div></div>
<ul>
  <li>object에 무엇을 비교하냐에 따라서 현재 Working directory와 차이점을 출력해 준다.
<img src="/images/posts/2023-09-13-What-is-the-commit-on-Git/git-command-diff.jpg" title="Git command to show difference between objects" alt="Git command to show difference between objects" /></li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 Git의 핵심 요소인 Commit에 관하여 자세히 알아봤다. 앞으로 우리가 다룰 모든 명령어는 이 commit이라는 재료를 통해 실행되기 때문에 백번 강조해도 모자라지 않을 만큼 중요한 개념이다. 사실 어렵게 생각할 필요도 없다. 포스트를 시작하며 언급했던 것처럼 commit은 포도알 하나하나이고 이들을 모은 포도송이가 하나의 기능이 되는 것이다. 다음 포스트에서는 기록해 둔 commit들을 원격 저장소로 전송하고 다시 로컬 저장소에 내려받아 보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git commit" /><category term="git log" /><category term="git show" /><category term="git diff" /><summary type="html"><![CDATA[포도 없는 포도송이는 의미가 없듯이 Commit 없는 Git 또한 의미가 없다. Git의 핵심 요소인 Commit이란 무엇인지 알아보자.]]></summary></entry><entry><title type="html">5. Git 저장소에서 작업하기</title><link href="http://localhost:4000/github/2023/09/11/Working-in-Git-repository/" rel="alternate" type="text/html" title="5. Git 저장소에서 작업하기" /><published>2023-09-11T06:49:13+09:00</published><updated>2023-09-11T06:49:13+09:00</updated><id>http://localhost:4000/github/2023/09/11/Working-in-Git-repository</id><content type="html" xml:base="http://localhost:4000/github/2023/09/11/Working-in-Git-repository/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#간단한-작업-예시를-만들어보자" title="Navigate to Let's make an example for training">간단한 작업 예시를 만들어보자</a></li>
    <li><a href="#파일-상태-확인하기" title="Navigate to Checking file status in Git repository">파일 상태 확인하기</a></li>
    <li><a href="#파일-추적하기" title="Navigate to Tracking in Git repository">파일 추적하기</a>
      <ul>
        <li><a href="#-만약-실습-도중-실수할-상황에-대비하여-몇-가지-복귀-명령어들을-미리-알아보자" title="Navigate to Command to restore file for Git">파일 복귀 명령어</a></li>
      </ul>
    </li>
    <li><a href="#추적중인-파일-이름-변경하기" title="Navigate to Changing the name of file which is already staged in Git repository">추적중인 파일 이름 변경하기</a></li>
    <li><a href="#추적하고-싶지-않은-파일-목록" title="Navigate to The list willing to ignore in Git repository">추적하고 싶지 않은 파일 목록</a></li>
  </ol>
</blockquote>

<hr />

<h4 id="간단한-작업-예시를-만들어보자"><span style="color: brown"><strong>간단한 작업 예시를 만들어보자</strong></span></h4>
<ul>
  <li>
    <p><a href="/github/2023/08/28/Essential-terminal-commands" title="Navigate to 3. 필수적인 터미널 명령어를 알아보자 post">이전 포스트</a>에서 알아봤던 기본적인 터미널 명령어를 이용하여 실습환경을 만들어보자.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/making-training-environment-by-terminal-command.jpg" title="Making training environment by terminal command" alt="Making training environment by terminal command" /></p>
  </li>
  <li>
    <p>간단하게 프로젝트 모양새를 만들어보았다. 이제 Git 저장소 내의 파일들의 상태를 확인해 보자.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/directory-for-training-git.jpg" title="Directory for training git" alt="Directory for training git" /></p>
  </li>
</ul>

<hr />

<h4 id="파일-상태-확인하기"><span style="color: brown"><strong>파일 상태 확인하기</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git status
</code></pre></div></div>
<ul>
  <li>Git 저장소 내의 <span style="color: #8D4801"><strong>파일들의 상태를 확인하는 명령어</strong></span>이다.</li>
  <li>Git을 사용하는 동안 정말 많이 사용하게 되는 명령어 중 하나이다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-status.jpg" title="Git command to check file status" alt="Git command to check file status" /></li>
</ul>

<hr />

<h4 id="파일-추적하기"><span style="color: brown"><strong>파일 추적하기</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add &lt;옵션&gt; &lt;파일명 1&gt; &lt;파일명 2&gt; ...
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add <span class="nb">.</span>
</code></pre></div></div>
<ul>
  <li>Git 저장소 내의 <span style="color: #8D4801"><strong>Unstage 상태의 파일들을 추적하는 명령어</strong></span>이다. 경로에 “.”을 사용할 경우 현재 경로 내의 모든 파일을 추적한다.</li>
  <li>새로 추가, 생성된 파일들뿐만 아니라 기존에 add 되어서 Stage 상태였던 파일들이 Modified 되어서 Unstage 상태가 된 경우 또한 모두 추적한다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-add.jpg" title="Git command to track the files to commit" alt="Git command to track the files to commit" /></li>
</ul>

<p><br /></p>

<h6 id="-만약-실습-도중-실수할-상황에-대비하여-몇-가지-복귀-명령어들을-미리-알아보자"><span style="color: indianred"><strong>※ 만약 실습 도중 실수할 상황에 대비하여 몇 가지 복귀 명령어들을 미리 알아보자.</strong></span></h6>
<ul>
  <li><strong>commit 이력이 없는 추적 중인 파일을 Unstage 상태로 변경하는 명령어</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git <span class="nb">rm</span> <span class="nt">-cached</span> &lt;파일명&gt;
</code></pre></div>    </div>
    <ul>
      <li><span style="color: #8D4801"><strong>파일을 추적한 후 commit 하지 않은 상태에서 바로 삭제할 때 사용할 수 있다.</strong></span> 해당 파일을 이미 한 번이라도 commit 했다면 이전 commit 기준으로 해당 파일의 삭제 또한 변화된 이력으로 간주하기 때문에 파일이 여전히 tracked 상태인 것을 확인할 수 있다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-rm-cached.jpg" title="Git command to remove cached files" alt="Git command to remove cached files" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>commit 이력이 있는 추적 중인 파일을 Unstage 상태로 변경하는 명령어</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset HEAD &lt;파일명&gt;
</code></pre></div>    </div>
    <ul>
      <li>현재 HEAD가 가리키는 commit 이력의 상태로 파일의 이력을 되돌려서 Unstage 상태로 만들 수 있다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-reset-HEAD.jpg" title="Git command to reset to HEAD commit" alt="Git command to reset to HEAD commit" /></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git restore <span class="nt">--staged</span> &lt;파일명&gt;
</code></pre></div>    </div>
    <ul>
      <li>Stage 상태의 파일을 Unstage 상태로 복구시킨다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-restore-staged.jpg" title="Git command to restore to recent commit" alt="Git command to restore to recent commit" /></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="추적-중인-파일-이름-변경하기"><span style="color: brown"><strong>추적 중인 파일 이름 변경하기</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git <span class="nb">mv</span> &lt;파일명&gt; &lt;새 파일명&gt;
</code></pre></div></div>
<ul>
  <li>터미널 명령어인 mv와 같이 파일명을 바꾸는 명령어로써 주된 목적은 Git 저장소 내의 이미 추적 중인 파일명을 변경하는 명령어이다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/git-command-mv.jpg" title="Git command to change the name of file which is already staged" alt="Git command to change the name of file which is already staged" /></li>
</ul>

<p><br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv</span> &lt;파일명&gt; &lt;새 파일명&gt;
git <span class="nb">rm</span> &lt;파일명&gt;
git add &lt;새 파일명&gt;
</code></pre></div></div>
<ul>
  <li>풀어서 작성하면 위와 같이 작성할 수 있다. Git 명령어를 사용하지 않고 그냥 파일명을 변경하면 기존의 추적 중이던 파일명은 삭제 상태가 되고 새로운 파일명은 추가된 상태가 되므로 삭제 상태의 파일명 이력은 지우고 추가된 상태의 새로운 파일명은 다시 추적하면 똑같은 동작을 한다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/example-that showing-same-result-with-git-mv-command.jpg" title="Example that showing same result with git mv command" alt="Example that showing same result with git mv command" /></li>
</ul>

<hr />

<h4 id="추적하고-싶지-않은-파일-목록"><span style="color: brown"><strong>추적하고 싶지 않은 파일 목록</strong></span></h4>
<ul>
  <li><strong>.gitignore 파일</strong>
    <ul>
      <li>git은 이 파일에 작성된 <span style="color: #8D4801"><strong>목록들을 추적하지 않는다.</strong></span></li>
      <li>또 로컬 저장소를 서버로 전송하거나 다른 사람과 공유할 때도 이를 <span style="color: #8D4801"><strong>예외 처리</strong></span>한다.</li>
      <li>.gitignore 파일을 작성할 때는 <span style="color: #8D4801"><strong>반드시 저장소 폴더의 최상위 디렉토리에 두어야 한다.</strong></span> (.git 디렉토리와 같은 경로)</li>
      <li>파일 안에 # 으로 시작하는 줄은 주석으로 처리된다.</li>
      <li>와일드카드(*)를 사용하여 패턴을 정의할 수 있다. (셸 글로빙)</li>
      <li>ex)
        <ul>
          <li>package-lock.json (풀네임)</li>
          <li><span style="color: #8D4801"><strong>*</strong></span>.DS_Store (해당 확장자를 가진 모든 파일을 제외함)</li>
          <li><span style="color: #8D4801"><strong>!</strong></span>index.html (이 파일은 제외하면 안 됨)</li>
          <li><span style="color: #8D4801"><strong>/</strong></span>404.html (현재 디렉토리 안에 있는 파일 무시)</li>
          <li><span style="color: #8D4801"><strong>/</strong></span>_site<span style="color: #8D4801"><strong>/</strong></span> (/_site/ 디렉토리 안의 모든 것을 무시)</li>
          <li>
            <p>image<span style="color: #8D4801"><strong>/**/*</strong></span>.gif (image 디렉토리 아래의 모든 .gif 파일 무시)
<img src="/images/posts/2023-09-11-Working-in-Git-repository/making-gitlignore-file-by-terminal-command.jpg" title="Making gitlignore file by terminal command" alt="Making gitlignore file by terminal command" /></p>
          </li>
          <li>vim 에디터를 이용하여 .gitignore 파일에 무시할 파일들을 추가하는 예시이다.
<img src="/images/posts/2023-09-11-Working-in-Git-repository/setting-gitignore-file-by-vim-editor.jpg" title="Setting gitignore file by vim editor" alt="Setting gitignore file by vim editor" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 프로젝트 작업을 가정한 디렉토리를 터미널 명령어로 간단하게 생성해 보고 그 파일들의 상태를 직접 확인한 후 추적도 하고 복귀도 시켜보았다. <a href="/github/2023/09/04/Git-repository-concept-and-principle" title="Navigate to 4. Git 저장소 개념과 원리 post">바로 이전 포스트</a>에서 알아보았던 이론들을 실제로 실습해 본 시간이었는데 결국 모든 코딩은 직접 타이핑을 해보아야 알게 된 이론이 정리가 되므로 꼭 한 번씩 타이핑해 보시길 추천해 드린다. 다음 포스트에서는 Git의 알파이자 오메가라고 불러도 과언이 아닐 Commit에 대해서 알아보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="git status" /><category term="git add" /><category term="gitignore" /><summary type="html"><![CDATA[생성한 Git 저장소에서 간단한 작업을 해보자. 그리고 그 파일을 추적하고 상태도 확인해 보자.]]></summary></entry><entry><title type="html">4. Git 저장소 개념과 원리</title><link href="http://localhost:4000/github/2023/09/04/Git-repository-concept-and-principle/" rel="alternate" type="text/html" title="4. Git 저장소 개념과 원리" /><published>2023-09-04T14:11:27+09:00</published><updated>2023-09-04T14:11:27+09:00</updated><id>http://localhost:4000/github/2023/09/04/Git-repository-concept-and-principle</id><content type="html" xml:base="http://localhost:4000/github/2023/09/04/Git-repository-concept-and-principle/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#git-저장소-생성하기" title="Navigate to Initializing Git repository">Git 저장소 생성하기</a></li>
    <li><a href="#git-저장소-복제하기" title="Navigate to Copying Git repository">Git 저장소 복제하기</a></li>
    <li><a href="#git-디렉토리를-파헤쳐보자" title="Navigate to Let's dig into the .git directory">.git 디렉토리를 파헤쳐보자</a></li>
    <li><a href="#git-저장소의-구조" title="Navigate to The structure of git repository">Git 저장소의 구조</a>
      <ul>
        <li><a href="#working-directory" title="Navigate to Working directory">작업 디렉토리</a></li>
        <li><a href="#stage-area" title="Navigate to Stage area">스테이지 영역</a></li>
        <li><a href="#local-repository" title="Navigate to Local repository">로컬 저장소</a></li>
      </ul>
    </li>
    <li><a href="#git-저장소-동작-원리" title="Navigate to The principle of git repository">Git 저장소 동작 원리</a>
      <ul>
        <li><a href="#tracked--untracked-status" title="Navigate to Tracking status">추적 상태</a></li>
        <li><a href="#modified--unmodified-status" title="Navigate to Modifying status">수정 상태</a></li>
        <li><a href="#stage--unstage-status" title="Navigate to Stage status">스테이지 상태</a></li>
      </ul>
    </li>
  </ol>
</blockquote>

<hr />

<h4 id="git-저장소-생성하기"><span style="color: brown"><strong>Git 저장소 생성하기</strong></span></h4>
<p>평범한 디렉토리를 Git 저장소로 둔갑시켜 주는 마법의 명령어는 다음과 같다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init &lt;경로&gt;
</code></pre></div></div>
<ul>
  <li>init 명령어를 처음 실행하면 경로 안에 <span style="color: #8D4801"><strong>새로운 .git 디렉토리를 생성</strong></span>한다. 일반적으로 이미 Git 저장소인 경로에 실행할 경우 이미 .git 디렉토리가 존재하며, 그 안에 Git 저장소에 필요한 모든 정보가 포함되어 있으므로 실행되더라도 아무런 변화가 없을 수 있다.</li>
  <li>경로를 입력하지 않으면 현재 디렉토리에서 초기화된다.</li>
  <li>항목 이름이 .으로 시작하는 항목들은 운영체제의 구분 없이 <span style="color: #8D4801"><strong>숨겨져 있어서</strong></span> 일반적인 방법으로는 찾을 수 없다.
    <ul>
      <li><span style="color: #8D4801"><strong>Windows</strong></span>의 경우 메뉴 &gt; 보기 &gt; 숨긴 항목 보기에 체크하면 확인할 수 있다.</li>
      <li><span style="color: #8D4801"><strong>Mac</strong></span>의 경우 command+shift+. 단축키를 사용하여 숨겨진 항목들이 보이게 할 수 있다.</li>
      <li><span style="color: #8D4801"><strong>경로(path)</strong></span> 상의 .은 <span style="color: #8D4801"><strong>현재 경로</strong></span>를 뜻한다. 그러나, <span style="color: #8D4801"><strong>파일 및 디렉토리</strong></span> 앞의 .은 <span style="color: #8D4801"><strong>숨겨진 파일 및 디렉토리</strong></span>를 의미한다.</li>
    </ul>
  </li>
  <li>ls -a 옵션을 통해 숨겨진 항목을 출력해야만 확인할 수 있다.
<img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/git-command-init.jpg" title="Git command to initialize the directory as git repository" alt="Git command to initialize the directory as git repository" /></li>
</ul>

<hr />

<h4 id="git-저장소-복제하기"><span style="color: brown"><strong>Git 저장소 복제하기</strong></span></h4>
<p>다음으로 이미 존재하는 외부의 저장소를 복제해 오는 명령어이다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone &lt;원격 저장소 URL&gt; &lt;새 디렉토리명&gt;
</code></pre></div></div>
<ul>
  <li>clone 명령어를 실행하면 <span style="color: #8D4801"><strong>현재 디렉토리에 원격 저장소를 복제한다.</strong></span> 복제한 디렉토리 안에는 당연히 .git 디렉토리가 존재하며 기존 원격 저장소의 이력을 저장하고 있다.</li>
  <li>새 디렉토리명을 입력하지 않으면 원격 저장소의 디렉토리 명이 기본값으로 설정된다.</li>
  <li>원격 저장소의 이름은 origin이 기본값으로 설정된다.
<img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/git-command-clone.jpg" title="Git command to copy the remote directory to local repository" alt="Git command to copy the remote directory to local repository" /></li>
</ul>

<hr />

<h4 id="git-디렉토리를-파헤쳐보자"><span style="color: brown"><strong>.git 디렉토리를 파헤쳐보자</strong></span></h4>
<ul>
  <li>
    <p>처음 git init을 하면 .git 디렉토리가 생성되고 이 디렉토리가 버전관리에 관련된 모든 정보를 가진다는 얘기를 들었을 때 호기심이 일었던 것 같다. 대체 이 안에 무엇이 들어있고 어떻게 생겼길래 새로운 데이터가 생겨나기도 하고 실수를 만회하고자 과거의 데이터로 돌아가기도 하고 할 수 있는 걸까? 테이블을 통해 간단히 알아보자.</p>
  </li>
  <li>
    <p>저장소를 처음 초기화했을 때 .git directory 안에 생성되는 항목들이다.</p>
  </li>
</ul>

<p><img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/things-inside-of-git-directory-when-initialized.jpg" title="Files and directories in .git directory when it's initialized" alt="Files and directories in .git directory when it's initialized" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>config</strong></td>
      <td style="text-align: center">저장소의 환경설정 파일이다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>description</strong></td>
      <td style="text-align: center">Git 원격 저장소의 설명을 담고 있는 파일이다. 이 파일은 주로 웹 인터페이스에서 Git 저장소를 표시할 때 사용된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>HEAD</strong></td>
      <td style="text-align: center">현재 작업 중인 브랜치를 가리키는 포인터이다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>hooks</strong></td>
      <td style="text-align: center">Git 훅 스크립트가 저장되는 디렉토리이다. commit이나 merge 등의 이벤트 발생 시 실행되는 스크립트를 작성하여 저장할 수 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>info</strong></td>
      <td style="text-align: center">저장소의 부가적인 정보를 담고 있는 디렉토리이다. 예를 들어 exclude 파일과 alternates 파일이 여기에 저장된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>objects</strong></td>
      <td style="text-align: center">Git이 관리하는 모든 객체가 저장되는 디렉토리이다. 객체는 blob(파일 내용), tree(디렉토리 구조), commit(커밋 정보) 등을 포함한다. (보이기엔 정체불명의 파일과 디렉토리가 엄청 많다.)</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>refs</strong></td>
      <td style="text-align: center">참조(브랜치나 태그) 정보를 담고 있는 디렉토리이다. heads 디렉토리는 로컬 브랜치의 정보를, remotes 디렉토리는 원격 브랜치의 정보를, tags 디렉토리는 태그의 정보를 담고 있다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<ul>
  <li>어느 정도 사용한 저장소의 .git directory안에 생성되어 있는 항목들이다. 위에 없었던 항목들만 살펴보자.</li>
</ul>

<p><img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/things-inside-of-git-directory.jpg" title="Files and directories in .git directory" alt="Files and directories in .git directory" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>COMMIT_EDITMSG</strong></td>
      <td style="text-align: center">Git 커밋 메시지를 작성하는 데 사용되는 임시 파일이다. 커밋을 만들 때 사용자가 지정한 에디터에서 커밋 메시지를 편집하는 동안, 이 파일에 작성된 내용이 편집기에 표시된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>FETCH-HEAD</strong></td>
      <td style="text-align: center">원격 저장소에서 가져온 브랜치의 상태 정보를 담고 있는 파일이다. git fetch 명령을 실행하면 원격 저장소의 변경 사항이 이 파일에 기록된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>index</strong></td>
      <td style="text-align: center">Git의 Stage 영역에 있는 파일들의 정보를 담고 있는 파일이다. Stage 영역에 추가된 파일들의 이름, 경로, 상태 등이 이 파일에 저장된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>index 2</strong></td>
      <td style="text-align: center">index 파일과 마찬가지로 스테이징 영역에 있는 파일들의 정보를 담고 있는 파일이다. 일반적으로 사용되지 않는 파일로, 일부 Git 클라이언트나 GUI 도구에서 사용되는 경우가 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>logs</strong></td>
      <td style="text-align: center">로그 파일을 저장하는 디렉토리이다. 주로 HEAD와 브랜치의 변경 이력이 이 디렉토리에 저장된다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>ORIG_HEAD</strong></td>
      <td style="text-align: center">이전에 git reset이나 git rebase 등의 명령을 사용하여 이동된 HEAD의 이전 위치를 가리키는 참조이다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>packed-refs</strong></td>
      <td style="text-align: center">Git의 참조(브랜치, 태그 등)들을 압축해서 저장하는 파일이다. 이 파일은 참조의 목록과 각각 참조의 해시값을 포함하고 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>sourcetreeconfig</strong></td>
      <td style="text-align: center">Sourcetree 프로그램이 사용하는 설정 파일이다. 이 파일은 사용자 지정 설정이나 환경 변수 등을 포함할 수 있다. Sourcetree 프로그램이 없거나 사용하지 않는다면 이 파일은 사용되지 않는다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<ul>
  <li>무언가 많다는 건 알겠는데 아직 뭐가 뭔지는 모르겠다. 괜찮다. 어차피 우리가 작업할 때 이 디렉토리를 직접적으로 편집해야 할 일은 거의 없다.</li>
</ul>

<hr />

<h4 id="git-저장소의-구조"><span style="color: brown"><strong>Git 저장소의 구조</strong></span></h4>
<p><span style="color: #8D4801"><strong>Git 저장소</strong></span>는 크게 <span style="color: #8D4801"><strong>3가지</strong></span>로 나뉜다.</p>

<p><img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/the-structure-of-git-repository.png" title="The structure of git repository" alt="The structure of git repository" /></p>

<h5 id="working-directory"><span style="color: green"><strong>Working directory</strong></span></h5>
<ul>
  <li>init 명령어 실행 시 Original directory를 기반으로 Working directory가 존재한다. (쉽게 생각하자면 그냥 일반 directory라고 생각하면 된다. 당연하다. 아직 아무것도 수정되지 않았다.)</li>
  <li>Working directory는 현재 작업 중인 <span style="color: #8D4801"><strong>실제 파일들이 위치하는 directory</strong></span>이며 변경된 파일이나 새로운 파일이 추가되는 곳이다. <span style="color: #8D4801"><strong>기본적으로 Git은 이곳에 있는 파일을 추적하거나 관리하진 않는다.</strong></span></li>
  <li><span style="color: #8D4801"><strong>추가, 수정된 파일들을 add 명령어를 통해서 추적 상태로 만들고 Stage area로 이동시킨다.</strong></span></li>
</ul>

<p><br /></p>

<h5 id="stage-area"><span style="color: red"><strong>Stage area</strong></span></h5>
<ul>
  <li><span style="color: #8D4801"><strong>가상의 임시 저장 공간</strong></span>이다.(가상이라고 적었듯이 실제 파일이 존재하는 것이 아니다.)</li>
  <li>추적 상태로 <span style="color: #8D4801"><strong>수정된 파일들은 Unstage 상태로 변한다.</strong></span> (다시 add 명령어를 통해서 Stage 상태로 만들어야 한다.)</li>
  <li>이 영역의 파일들은 오로지 다음 commit을 위해 존재한다. <span style="color: #8D4801"><strong>commit 명령어가 실행되면 모든 파일을 Local repository로 보내고 영역을 비운다.</strong></span></li>
</ul>

<p><br /></p>

<h5 id="local-repository"><span style="color: darkorange"><strong>Local repository</strong></span></h5>
<ul>
  <li>commit 된 파일의 버전들이 저장되는 곳이다. <span style="color: #8D4801"><strong>모든 커밋된 파일의 스냅샷이 저장되며</strong></span>, Working directory로 부터의 변경 사항은 여기서 실제로 커밋된다.</li>
  <li>위의 그림에서 Base data가 git 저장소 초기화 전 시점이라고 가정하고 현재 Local repository에 기록되어 있는 모든 변경 사항을 Base data에 적용한 결과물이 저장돼 있는 것이 Working directory이다. 즉, Local repository에 이력이 수정되면 실제 Working directory에도 수정된 결과물이 저장되어 있다.</li>
</ul>

<hr />

<h4 id="git-저장소-동작-원리"><span style="color: brown"><strong>Git 저장소 동작 원리</strong></span></h4>
<p><span style="color: #8D4801"><strong>Git 저장소 내 파일들</strong></span>은 크게 <span style="color: #8D4801"><strong>3종류</strong></span>의 상태를 갖는다.</p>

<p><img src="/images/posts/2023-09-04-Git-repository-concept-and-principle/the-principle-of-git-repository.png" title="The principle of git repository" alt="The principle of git repository" /></p>

<h5 id="tracked--untracked-status"><strong><span style="color: dodgerblue">Tracked</span><span style="color: #8D4801"> / </span><span style="color: steelblue">Untracked</span><span style="color: #8D4801"> status</span></strong></h5>
<ul>
  <li>앞에서 얘기했듯이 Git은 Working directory에 있는 파일을 추적하지 않는다. 즉 <span style="color: #8D4801"><strong>모든 새로운 파일들은 기본적으로 Untracked 상태이다.</strong></span></li>
  <li>사용자가 Git에게 버전관리가 있어야 하는 파일들에 대해서 추적을 요청해야 파일의 변경이력이 추적된다. <span style="color: #8D4801"><strong>파일을 Tracked 상태로 변경하여 Git에게 관리를 부탁하는 명령어가 add 명령어이다.</strong></span></li>
</ul>

<p><br /></p>

<h5 id="modified--unmodified-status"><strong><span style="color: limegreen">Modified</span><span style="color: #8D4801"> / </span><span style="color: lightseagreen">Unmodified</span><span style="color: #8D4801"> status</span></strong></h5>
<ul>
  <li>단어의 의미 그대로 <span style="color: #8D4801"><strong>파일이 수정된 상태인지 아닌지</strong></span>를 나타낸다. 기준이 되는 시점은 파일이 처음 Tracked 상태가 된 시점과 이미 Tracked 상태의 파일이라면 가장 최근에 Modified 상태에서 Unmodified 상태가 된 시점을 기준으로 수정 여부를 판단한다.</li>
</ul>

<p><br /></p>

<h5 id="stage--unstage-status"><strong><span style="color: red">Stage</span><span style="color: #8D4801"> / </span><span style="color: hotpink">Unstage</span><span style="color: #8D4801"> status</span></strong></h5>
<ul>
  <li>쉽게 생각하면 <span style="color: #8D4801"><strong>파일의 commit이 가능한 상태(Stage) or 불가능한 상태(Unstage)이다.</strong></span> 위의 그림을 보면서 이해해 보자.
    <ol>
      <li>먼저 Git이 파일의 버전관리를 하기 위해선 반드시 add 명령어를 통해 Tracked 상태가 되어야 한다고 했다. 즉, <span style="color: #8D4801"><strong>add 되지 않은 Untracked 파일들은 모두 Unstage 상태이다.</strong></span></li>
      <li><span style="color: #8D4801"><strong>새로운 파일이 처음 add 되었을 때 Stage 상태가 된다.</strong></span> 추적됨과 동시에 수정되지 않은 상태이기 때문이다. (방금 추가되었으므로 수정된 이력이 없다.)</li>
      <li><span style="color: #8D4801"><strong>이미 추적 중이던 파일이 사용자에 의해서 수정되면 Modified 상태가 되므로 Unstage 상태가 된다.</strong></span> 이런 상황에는 해당 파일에 add 명령어를 사용하면 다시 Stage 상태로 만들 수 있다.</li>
    </ol>
  </li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 Git 저장소를 생성하고 그 구조와 원리에 대하여 알아보았다. 필자는 처음 Git에 입문할 때 “SVN이라는 버전관리 도구를 사용해 본 경험이 있으니까 비슷한 구조가 아닐까?”라는 막연한 생각으로 시작했다가 도무지 Git이 어떻게 동작하는 것인지 이해가 안 가서 어려움을 겪었던 기억이 있다. 그러나, 그것은 마냥 명령어 암기에 집중된 공부 방식이 문제였던 것 같다. 개발자가 본인이 사용하는 명령어가 무엇인지 모르고 사용하는 것만큼 위험한 게 또 있을까? 다행히 이후에 바탕이 되는 개념을 이해하려고 노력한 뒤부터 Git에 점점 친숙해질 수 있었던 것 같다. 다음 포스트에서는 생성한 Git 저장소에 실제 작업을 진행하고 알아본 이론을 적용해 보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Git" /><category term="Github" /><category term="깃" /><category term="깃허브" /><category term="Git 저장소" /><category term="Git repository" /><category term="git init" /><category term="git clone" /><summary type="html"><![CDATA[Git 저장소를 생성하고 버전관리 동작 원리를 알아보자.]]></summary></entry><entry><title type="html">3. 필수적인 터미널 명령어를 알아보자</title><link href="http://localhost:4000/github/2023/08/28/Essential-terminal-commands/" rel="alternate" type="text/html" title="3. 필수적인 터미널 명령어를 알아보자" /><published>2023-08-28T10:47:23+09:00</published><updated>2023-08-28T10:47:23+09:00</updated><id>http://localhost:4000/github/2023/08/28/Essential-terminal-commands</id><content type="html" xml:base="http://localhost:4000/github/2023/08/28/Essential-terminal-commands/"><![CDATA[<blockquote>
  <ol>
    <li><a href="#cd-명령어" title="Navigate to cd command">cd 명령어</a></li>
    <li><a href="#ls-명령어" title="Navigate to ls command">ls 명령어</a></li>
    <li><a href="#pwd-명령어" title="Navigate to pwd command">pwd 명령어</a></li>
    <li><a href="#mkdir-명령어" title="Navigate to mkdir command">mkdir 명령어</a></li>
    <li><a href="#rmdir-명령어" title="Navigate to rmdir command">rmdir 명령어</a></li>
    <li><a href="#touch-명령어" title="Navigate to touch command">touch 명령어</a></li>
    <li><a href="#rm-명령어" title="Navigate to rm command">rm 명령어</a></li>
    <li><a href="#mv-명령어" title="Navigate to mv command">mv 명령어</a></li>
    <li><a href="#cp-명령어" title="Navigate to cp command">cp 명령어</a></li>
    <li><a href="#echo-명령어" title="Navigate to echo command">echo 명령어</a></li>
    <li><a href="#cat-명령어" title="Navigate to cat command">cat 명령어</a></li>
    <li><a href="#less-명령어" title="Navigate to less command">less 명령어</a></li>
    <li><a href="#find-명령어" title="Navigate to find command">find 명령어</a></li>
    <li><a href="#터미널-제어-명령어" title="Navigate to The commands to control a terminal">터미널 제어 명령어</a></li>
  </ol>
</blockquote>

<hr />

<h4 id="cd-명령어"><span style="color: brown"><strong>cd 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> &lt;디렉토리 경로&gt; : 입력한 디렉토리 경로로 이동
<span class="nb">cd</span> .. : 부모 디렉토리로 이동 <span class="o">(</span>한 단계 상위 디렉토리<span class="o">)</span>
<span class="nb">cd</span> : 경로를 입력하지 않으면 최상위 디렉토리로 이동
<span class="nb">cd</span> ~ : 최상위 디렉토리로 이동
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>C</strong></span>hange <span style="color: #8D4801"><strong>D</strong></span>irectory의 약자로 작업할 디렉토리간 이동에 쓰이는 명령어이다. 매우 자주 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-cd.jpg" title="Terminal command to change directory" alt="Terminal command to change directory" /></li>
</ul>

<hr />

<h4 id="ls-명령어"><span style="color: brown"><strong>ls 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> : 해당 경로 안 파일 및 디렉토리들의 리스트 출력
<span class="nb">ls</span> <span class="nt">-l</span> : 리스트 자세한 내용과 함께 출력 <span class="o">(</span>long<span class="o">)</span> // 크기, 수정 시간[mtime], 권한 및 소유권
<span class="nb">ls</span> <span class="nt">-a</span> : 숨겨진 파일 및 디렉토리들을 포함하여 리스트 출력 <span class="o">(</span>all<span class="o">)</span>
<span class="nb">ls</span> <span class="nt">-S</span> : 파일 크기순으로 정렬하여 리스트 출력 <span class="o">(</span>size<span class="o">)</span>
<span class="nb">ls</span> <span class="nt">-r</span> : 역순으로 출력, 기본값은 알파벳 순서이다. <span class="o">(</span>reverse<span class="o">)</span>
<span class="nb">ls</span> <span class="nt">-R</span> : 하위 디렉토리까지 출력 <span class="o">(</span>recursive<span class="o">)</span>
<span class="nb">ls</span> <span class="nt">-h</span> : 파일 크기 단위[k, m, g]를 표시하여 사람이 보기 좋게 출력 <span class="o">(</span>human<span class="o">)</span>
<span class="nb">ls</span> <span class="nt">-lu</span> : 자세한 내용에 수정 시간[mtime] 대신 접근 시간[atime]을 출력
<span class="nb">ls</span> <span class="nt">-lc</span> : 자세한 내용에 수정 시간[mtime] 대신 변경 시간[ctime]을 출력
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>L</strong></span>i<span style="color: #8D4801"><strong>s</strong></span>t의 약자로 현재 디렉토리 안 파일 및 디렉토리들의 리스트를 보여주는 명령어이다. ls 명령어로 폴더 리스트를 확인하고 cd 명령어를 이용해 디렉토리를 이동하는 등 매우 자주 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-ls-alh.jpg" title="Terminal command to show the list in the path" alt="Terminal command to show the list in the path" /></li>
</ul>

<hr />

<h4 id="pwd-명령어"><span style="color: brown"><strong>pwd 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">pwd</span> : 현재 디렉토리의 절대경로를 출력
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>P</strong></span>rint <span style="color: #8D4801"><strong>W</strong></span>orking <span style="color: #8D4801"><strong>D</strong></span>irectory의 약자로 현재 디렉토리의 경로를 확인할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-pwd.jpg" title="Terminal command to print working directory" alt="Terminal command to print working directory" /></li>
</ul>

<hr />

<h4 id="mkdir-명령어"><span style="color: brown"><strong>mkdir 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> &lt;디렉토리명&gt; : 현재 경로에 새로운 디렉토리 생성
<span class="nb">mkdir</span> <span class="nt">-p</span> &lt;경로&gt;/&lt;디렉토리명&gt; : 특정 경로에 새로운 디렉토리 생성 <span class="o">(</span>경로상에 존재하지 않는 폴더명이 있으면 생성<span class="o">)</span>
<span class="nb">mkdir</span> <span class="nt">-m</span> &lt;rwx[예<span class="o">)</span> 755]&gt; &lt;디렉토리명&gt; : 현재 경로에 접근 권한이 수정된 새로운 디렉토리 생성
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>M</strong></span>a<span style="color: #8D4801"><strong>k</strong></span>e <span style="color: #8D4801"><strong>Dir</strong></span>ectories의 약자로 현재 경로에 새로운 디렉토리들을 생성할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-mkdir.jpg" title="Terminal command to make new directories" alt="Terminal command to make new directories" /></li>
</ul>

<hr />

<h4 id="rmdir-명령어"><span style="color: brown"><strong>rmdir 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rmdir</span> &lt;디렉토리명&gt; : 현재 경로에 비어있는 디렉토리 삭제 <span class="o">(</span>디렉토리에 1개 이상의 파일 존재 시 삭제 불가능<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>R</strong></span>e<span style="color: #8D4801"><strong>m</strong></span>ove <span style="color: #8D4801"><strong>Dir</strong></span>ectories의 약자로 현재 경로에 비어있는 디렉토리들을 삭제할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-rmdir.jpg" title="Terminal command to remove empty directories" alt="Terminal command to remove empty directories" /></li>
</ul>

<hr />

<h4 id="touch-명령어"><span style="color: brown"><strong>touch 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch</span> &lt;파일명&gt; : 현재 경로에 새로운 빈 파일 생성
<span class="nb">touch</span> <span class="nt">-a</span> &lt;파일명&gt; : 접근 시간[atime]을 현재 시각으로 변경
<span class="nb">touch</span> <span class="nt">-d</span> &lt;<span class="s1">'YYYY-MM-DD hh:mm:ss'</span><span class="o">&gt;</span> &lt;파일명&gt; : 접근 시간[atime]과 수정 시간[mtime]을 특정 시간으로 변경
<span class="nb">touch</span> <span class="nt">-t</span> &lt;CCYYMMDDhhmm.ss&gt; &lt;파일명&gt; : 접근 시간[atime]과 수정 시간[mtime]을 특정 시간으로 변경
</code></pre></div></div>
<ul>
  <li>‘만지다’라는 뜻을 가진 <span style="color: #8D4801"><strong>touch</strong></span>와 같이 어루만지듯이 파일에 접근 및 수정하고 빈 파일을 생성할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-touch.jpg" title="Terminal command to make new empty files" alt="Terminal command to make new empty files" /></li>
</ul>

<hr />

<h4 id="rm-명령어"><span style="color: brown"><strong>rm 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> &lt;디렉토리 또는 파일명&gt; : 현재 경로에 비어있지 않은 디렉토리 및 파일 삭제
<span class="nb">rm</span> <span class="nt">-r</span> &lt;디렉토리 또는 파일명&gt; : 현재 경로에 비어있지 않은 디렉토리 및 파일들과 그 하위 디렉토리 및 파일들을 모두 삭제 <span class="o">(</span>recursive<span class="o">)</span>
<span class="nb">rm</span> <span class="nt">-f</span> &lt;디렉토리 또는 파일명&gt; : 삭제 명령을 강제로 실행 <span class="o">(</span>force<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>R</strong></span>e<span style="color: #8D4801"><strong>m</strong></span>ove의 약자로 현재 경로에 비어있지 않은 디렉토리 및 파일들을 삭제할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-rm.jpg" title="Terminal command to remove non-empty directories and files" alt="Terminal command to remove non-empty directories and files" /></li>
</ul>

<hr />

<h4 id="mv-명령어"><span style="color: brown"><strong>mv 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv</span> &lt;디렉토리 또는 파일의 경로&gt; &lt;이동시킬 경로&gt; : 이동시킬 경로로 디렉토리 및 파일을 이동
<span class="nb">mv</span> &lt;디렉토리 또는 파일1&gt; &lt;디렉토리 또는 파일2&gt; ... &lt;이동시킬 경로&gt; : 복수의 디렉토리 및 파일을 이동
<span class="nb">mv</span> <span class="k">*</span> &lt;이동시킬 경로&gt; : 현재 경로의 모든 디렉토리 및 파일을 이동
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>M</strong></span>o<span style="color: #8D4801"><strong>v</strong></span>e의 약자로 디렉토리 및 파일들의 경로를 이동할 때 쓰인다. 이동시킬 경로에 파일명을 다르게 입력할 경우 파일 이름을 변경할 수 있다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-mv.jpg" title="Terminal command to move directories and files" alt="Terminal command to move directories and files" /></li>
</ul>

<hr />

<h4 id="cp-명령어"><span style="color: brown"><strong>cp 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> &lt;디렉토리 또는 파일의 경로&gt; &lt;복사시킬 경로&gt; : 복사시킬 경로로 디렉토리 및 파일을 복사
<span class="nb">cp</span> <span class="nt">-r</span> &lt;디렉토리 또는 파일의 경로&gt; &lt;복사시킬 경로&gt; : 복사시킬 경로로 디렉토리 및 파일들과 그 하위 디렉토리 및 파일들을 모두 복사 <span class="o">(</span>recursive<span class="o">)</span>
<span class="nb">cp</span> <span class="nt">-f</span> &lt;디렉토리 또는 파일의 경로&gt; &lt;복사시킬 경로&gt; : 복사시킬 경로에 이미 같은 이름을 가진 디렉토리 또는 파일이 존재하더라도 복사 명령을 강제로 실행 <span class="o">(</span>force<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li><span style="color: #8D4801"><strong>C</strong></span>o<span style="color: #8D4801"><strong>p</strong></span>y의 약자로 디렉토리 및 파일들을 복사할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-cp.jpg" title="Terminal command to copy directories and files" alt="Terminal command to copy directories and files" /></li>
</ul>

<hr />

<h4 id="echo-명령어"><span style="color: brown"><strong>echo 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> &lt;문자열&gt; : 문자열을 화면에 출력
<span class="nb">echo</span> &lt;<span class="s2">"특수문자를 포함한 문자열"</span><span class="o">&gt;</span> : 특수문자를 포함한 문자열은 큰따옴표를 사용하여 화면에 출력
<span class="nb">echo</span> &lt;<span class="s2">"문자열"</span><span class="o">&gt;</span> <span class="o">&gt;</span> &lt;파일명&gt; : 파일이 존재할 경우 문자열을 덮어쓰기로 저장 존재하지 않을 경우 파일 생성
<span class="nb">echo</span> &lt;<span class="s2">"문자열"</span><span class="o">&gt;</span> <span class="o">&gt;&gt;</span> &lt;파일명&gt; : 파일이 존재할 경우 문자열을 이어서 저장 존재하지 않을 경우 파일 생성
</code></pre></div></div>
<ul>
  <li>‘메아리’라는 뜻을 가진 <span style="color: #8D4801"><strong>echo</strong></span>와 같이 입력한 문자열을 화면에 똑같이 출력할 때 쓰인다. 옵션에 따라 출력 내용을 파일에 입력할 수 있다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-echo.jpg" title="Terminal command to print out the string" alt="Terminal command to print out the string" /></li>
</ul>

<hr />

<h4 id="cat-명령어"><span style="color: brown"><strong>cat 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> &lt;텍스트 파일명&gt; : 텍스트 파일 내 문자들을 화면에 출력
<span class="nb">cat</span> &lt;텍스트 파일명1&gt; &lt;텍스트 파일명2&gt; ... : 여러 개의 텍스트 파일 내 문자들을 순차적으로 모두 화면에 출력
<span class="nb">cat</span> <span class="nt">-n</span> &lt;텍스트 파일명&gt; : 텍스트 파일 내 문자들을 화면에 line number와 함께 출력
</code></pre></div></div>
<ul>
  <li>Con<span style="color: #8D4801"><strong>cat</strong></span>enate의 약자로 하나 이상의 텍스트 파일을 화면에 출력할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-cat.jpg" title="Terminal command to print out the files" alt="Terminal command to print out the files" /></li>
</ul>

<hr />

<h4 id="less-명령어"><span style="color: brown"><strong>less 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>less &lt;텍스트 파일명&gt; : 텍스트 파일 내 문자들을 터미널 화면에 가득 찰 정도로 일부만 화면에 출력하고 페이지처럼 위아래로 탐색 조회
</code></pre></div></div>
<ul>
  <li>‘적다’라는 뜻을 가진 <span style="color: #8D4801"><strong>less</strong></span>와 같이 텍스트 파일에서 터미널 화면에 가득 찰 정도로 일부만 출력하고 위아래로 탐색할 수 있게 하여 크기가 큰 텍스트 파일을 편리하게 조회할 때 쓰인다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-less.jpg" title="Terminal command to print out a large size file one screen at a time" alt="Terminal command to print out a large size file one screen at a time" /></li>
</ul>

<hr />

<h4 id="find-명령어"><span style="color: brown"><strong>find 명령어</strong></span></h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> &lt;<span class="s1">'디렉토리 또는 파일명'</span><span class="o">&gt;</span> : 현재 디렉토리부터 찾고자 하는 디렉토리 또는 파일 검색
find <span class="nb">.</span> <span class="nt">-name</span> &lt;<span class="s1">'파일명'</span><span class="o">&gt;</span> <span class="nt">-type</span> f : 현재 디렉토리부터 찾고자 하는 파일만 검색
find <span class="nb">.</span> <span class="nt">-name</span> &lt;<span class="s1">'디렉토리명'</span><span class="o">&gt;</span> <span class="nt">-type</span> d : 현재 디렉토리부터 찾고자 하는 디렉토리만 검색
find <span class="nb">.</span> <span class="nt">-name</span> &lt;<span class="s1">'심볼릭링크명'</span><span class="o">&gt;</span> <span class="nt">-type</span> l : 현재 디렉토리부터 찾고자 하는 심볼릭링크만 검색
find / <span class="nt">-name</span> &lt;<span class="s1">'디렉토리 또는 파일명'</span><span class="o">&gt;</span> : 최상위 디렉토리부터 찾고자 하는 디렉토리 또는 파일 검색
find / <span class="nt">-name</span> &lt;<span class="s1">'*.특정 확장자'</span><span class="o">&gt;</span> : 최상위 디렉토리부터 특정 확장자를 가진 모든 파일 검색
find / <span class="nt">-name</span> &lt;<span class="s1">'abc*'</span><span class="o">&gt;</span> : 최상위 디렉토리부터 파일명이 abc로 시작하는 모든 파일 검색
find / <span class="nt">-name</span> &lt;<span class="s1">'파일명'</span><span class="o">&gt;</span> <span class="nt">-exec</span> &lt;터미널 명령어&gt; <span class="o">{}</span> <span class="se">\;</span> : 최상위 디렉토리부터 찾고자 하는 파일 검색 후 해당 파일에 명령어 실행 <span class="o">(</span>각 파일 별도로 프로세스 실행<span class="o">)</span>
find / <span class="nt">-name</span> &lt;<span class="s1">'파일명'</span><span class="o">&gt;</span> <span class="nt">-exec</span> &lt;터미널 명령어&gt; <span class="o">{}</span> + : 최상위 디렉토리부터 찾고자 하는 파일 검색 후 해당 파일에 명령어 실행 <span class="o">(</span>전체적으로 한 번만 실행<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>‘찾는다’라는 뜻을 가진 <span style="color: #8D4801"><strong>find</strong></span>와 같이 파일 시스템에서 파일을 찾을 때 쓰인다. 옵션과 표현식에 따라 사용 방식이 다양하다.
<img src="/images/posts/2023-08-28-Essential-terminal-commands/terminal-command-find.jpg" title="Terminal command to search for files on file system" alt="Terminal command to search for files on file system" /></li>
</ul>

<hr />

<h4 id="터미널-제어-명령어"><span style="color: brown"><strong>터미널 제어 명령어</strong></span></h4>
<ul>
  <li><span style="color: #8D4801"><strong>clear 명령어</strong></span>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear : 터미널의 내용을 모두 깔끔하게 지우는 명령어 <span class="o">(</span>iTerm2 기준으로 스크롤을 올리면 이전 내용을 볼 수 있음<span class="o">)</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><span style="color: #8D4801"><strong>sudo 명령어</strong></span>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> &lt;터미널 명령어&gt; : 최상위 권한으로 명령어를 실행함
</code></pre></div>    </div>
    <ul>
      <li><span style="color: #8D4801"><strong>S</strong></span>uper <span style="color: #8D4801"><strong>u</strong></span>ser <span style="color: #8D4801"><strong>do</strong></span>의 약자로 최상위 권한으로 명령어를 실행할 때 쓰인다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><span style="color: #8D4801"><strong>특수문자 \ 사용</strong></span>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>&lt;터미널 명령어1&gt; <span class="se">\</span>
<span class="nv">$ </span>&lt;터미널 명령어1&gt; <span class="se">\</span>
<span class="nv">$ </span>&lt;터미널 명령어1&gt; : 명령어가 한 줄안에 다 못 쓸정도로 길어질 경우 <span class="se">\ </span>문자를 사용하여 다음 줄에 이어서 명령어를 작성할 수 있다.
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li><span style="color: #8D4801"><strong>특수문자 ; 사용</strong></span>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>&lt;터미널 명령어1&gt;<span class="p">;</span> &lt;터미널 명령어2&gt;<span class="p">;</span> &lt;터미널 명령어3&gt; : 여러 명령어를 한 줄에 작성할 때 <span class="p">;</span> 문자를 사용하여 연결하면 순차적으로 명령어가 실행된다.
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h4 id="마무리하며">마무리하며…</h4>
<p>이번 포스트에서는 필수적인 터미널 명령어들을 알아보았다. 사실 Git을 처음 접하는 사람들이 대부분 이 터미널, 콘솔 환경에 대한 거부감 때문에 진입장벽이 생기는 것 같다. 그래서 설령 입문해도 터미널은 아예 배제하고 특정 GUI의 사용법만 익히는 등 터미널 자체를 익히지 않는 경우도 있다. 하지만, 아무리 GUI가 편리하고 꾸준히 기능들이 추가되고 있어도 여전히 터미널 환경이 아니면 해결하지 못하는 상황이 빈번하게 발생한다. CUI든 GUI든 누군가에게 강요해선 안 된다고 생각하지만, 어느 쪽을 메인으로 선택하든 개발자로서 Solution을 찾지 못하는 상황은 발생해서는 안 된다는 의견으로 결국 어느 쪽도 등한시할 수 없다고 생각한다. 다음 포스트에서는 Git의 개념과 원리에 대하여 함께 정리해 보는 시간을 가져보자.</p>]]></content><author><name></name></author><category term="Github" /><category term="Terminal commands" /><category term="터미널 명령어" /><summary type="html"><![CDATA[터미널 환경에서 Git을 사용하기 위해 필수적인 명령어에 무엇이 있는지 그리고 어떻게 사용하는지 알아보자.]]></summary></entry></feed>